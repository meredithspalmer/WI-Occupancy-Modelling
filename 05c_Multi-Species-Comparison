## ===========================================================
## Multi-species Occupancy Model Comparison Pipeline
## ===========================================================

## Setup ----------------------------------------------------------------------

# Set workspace
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights")
set.seed(123)
rm(list=ls()); gc()

# Load libraries
library(coda)
library(dplyr)
library(tidyr)
library(ggplot2)

# Define species groups
species_groups <- list(
  Bears = c("Helarctos malayanus", "Ursus thibetanus", "Melursus ursinus", 
            "Tremarctos ornatus", "Ursus americanus"),
  BigCats = c("Panthera onca", "Panthera pardus", "Panthera uncia", "Panthera tigris",
              "Lynx pardinus", "Acinonyx jubatus"),
  Tapirs = c("Tapirus bairdii", "Tapirus terrestris", "Tapirus pinchaque", 
             "Tapirus indicus"),
  Elephants = c("Loxodonta cyclotis", "Elephas maximus", "Loxodonta africana"),
  Rhinos = c("Ceratotherium simum", "Diceros bicornis"),
  Primates = c("Pan troglodytes", "Gorilla beringei", "Gorilla gorilla", 
               "Pongo pygmaeus"),
  Canids = c("Canis lupus", "Lycaon pictus", "Vulpes vulpes"), #Canis latrans, Urocyon cinereoargenteus are running 
  Ungulates = c("Antilocapra americana", "Odocoileus hemionus", "Odocoileus virginianus",
                "Dicotyles tajacu", "Tayassu pecari", "Sus scrofa"), 
  Marsupials = c("Notamacropus rufogriseus", "Trichosurus vulpecula", "Macropus giganteus"), 
  SmallMammals = c("Sciurus carolinensis", "Sciurus griseus", "Cuniculus paca", 
                   "Otospermophilus beecheyi", "Dasyprocta punctata") #Procyon lotor is running 
)

# Covariate labels (anthropogenic + trend)
cov_labels <- c(
  road_dist   = "Dist to Roads",
  cities_lg   = "Dist to Cities",
  crop        = "Proportion Crop",
  gpw         = "Human Population",
  gfc         = "Forest Loss",
  wdpa        = "Protected Area Status",
  trend       = "Trend (time)"
)

# Prepare file list
filenames <- list.files("Model outputs", pattern = "_svcTPGOcc\\.RData$", 
                        recursive = TRUE, full.names = TRUE)

# Function to extract occupancy response curves
occ_response <- function(out, dat_ls, covariates, n_points = 100) {
  beta_draws <- as.matrix(out$beta.samples)
  beta_names <- colnames(beta_draws)
  
  cov_means <- sapply(dat_ls$occ.covs, mean, na.rm = TRUE)
  cov_sds   <- sapply(dat_ls$occ.covs, sd, na.rm = TRUE)
  
  results <- list()
  
  for (cov_name in covariates) {
    beta_col <- paste0("scale(", cov_name, ")")
    if (!(beta_col %in% beta_names)) {
      stop(paste("No column in beta.samples matches", beta_col,
                 "\nAvailable:", paste(beta_names, collapse = ", ")))
    }
    
    cov_seq <- seq(min(dat_ls$occ.covs[[cov_name]], na.rm = TRUE),
                   max(dat_ls$occ.covs[[cov_name]], na.rm = TRUE),
                   length.out = n_points)
    cov_seq_scaled <- (cov_seq - cov_means[cov_name]) / cov_sds[cov_name]
    
    # design matrix
    X_pred <- matrix(0, nrow = n_points, ncol = ncol(beta_draws))
    colnames(X_pred) <- beta_names
    
    # intercept
    if ("(Intercept)" %in% beta_names) {
      X_pred[, "(Intercept)"] <- 1
    }
    
    # focal covariate
    X_pred[, beta_col] <- cov_seq_scaled
    
    # predict
    eta <- X_pred %*% t(beta_draws)
    psi <- plogis(eta)
    
    results[[cov_name]] <- data.frame(
      covariate = cov_seq,
      mean = rowMeans(psi),
      low = apply(psi, 1, quantile, 0.025),
      high = apply(psi, 1, quantile, 0.975),
      variable = cov_name
    )
  }
  
  dplyr::bind_rows(results)
}

# Function to extract summary statistics 
extract_beta_summary <- function(out, species_name) {
  beta_df <- as.data.frame(as.matrix(out$beta.samples))
  summary_df <- beta_df %>%
    pivot_longer(everything(), names_to = "term", values_to = "value") %>%
    group_by(term) %>%
    summarise(mean = mean(value),
              lower = quantile(value, 0.025),
              upper = quantile(value, 0.975)) %>%
    mutate(species = species_name)
  return(summary_df)
}


## Loop through groups --------------------------------------------------------
for (group_name in names(species_groups)) {
  species_list <- species_groups[[group_name]]
  message("Processing group: ", group_name)
  
  group_responses <- list()
  group_betas <- list()
  
  for (species_name in species_list) {
    message("  Processing species: ", species_name)
    
    file_species <- gsub(" ", "_", species_name)
    filename <- filenames[grep(file_species, filenames)]
    
    load(filename)
    
    # Ensure beta.samples is mcmc.list
    if (inherits(out$beta.samples, "mcmc")) {
      out$beta.samples <- as.mcmc.list(out$beta.samples)
    }
    
    # Extract only the selected covariates
    covs_to_plot <- intersect(names(dat_ls$occ.covs), names(cov_labels))
    res <- occ_response(out, dat_ls, covariates = covs_to_plot)
    res$species <- species_name
    group_responses[[species_name]] <- res
    
    # Extract beta summaries
    group_betas[[species_name]] <- extract_beta_summary(out, species_name)
  }
  
  # Combine data for the group
  plot_df <- bind_rows(group_responses) %>%
    filter(variable %in% names(cov_labels))
  
  beta_df <- bind_rows(group_betas) %>%
    mutate(term_clean = gsub("scale\\(|\\)", "", term)) %>%
    filter(term_clean %in% names(cov_labels))
  
  # Factorize variables for plotting
  plot_df$variable <- factor(plot_df$variable,
                             levels = names(cov_labels),
                             labels = cov_labels[names(cov_labels)])
  
  beta_df$term_clean <- factor(beta_df$term_clean,
                               levels = names(cov_labels),
                               labels = cov_labels[names(cov_labels)])
  
  # Occupancy response plot (all covariates)
  (p_cov <- ggplot(plot_df %>% filter(variable != "Trend (time)"),
                   aes(x = covariate, y = mean, color = species, fill = species)) +
      geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.1, color = NA) +
      geom_line(linewidth = 1) +
      facet_wrap(~ variable, scales = "free_x", ncol = 2) +
      labs(title = paste("Occupancy responses:", group_name),
           x = "Covariate value", y = "Occupancy probability") +
      theme_minimal(base_size = 12) +
      theme(legend.position = "bottom"))
  
  ggsave(paste0("Model outputs/", group_name, "_occResponses.jpg"),
         p_cov, width = 8, height = 6, units = "in", bg = "white")
  
  # Temporal trend plot
  if ("Trend (time)" %in% plot_df$variable) {
    (plot_time <- plot_df %>%
       filter(variable == "Trend (time)") %>%
       ggplot(aes(x = covariate, y = mean, color = species)) +
       geom_line(linewidth = 1) +
       geom_ribbon(aes(ymin = low, ymax = high, fill = species), alpha = 0.1, color = NA) +
       labs(title = paste("Occupancy trends over time:", group_name),
            x = "Time", y = "Occupancy probability") +
       theme_minimal(base_size = 12) +
       theme(legend.position = "bottom"))
    
    ggsave(paste0("Model outputs/", group_name, "_trendPlot.jpg"),
           plot_time, width = 6, height = 5, units = "in", bg = "white")
  }
  
  # Forest plot of beta coefficients
  (p_forest <- ggplot(beta_df %>% filter(term_clean != "Trend (time)"),
                      aes(x = mean, y = term_clean, color = species)) +
      geom_point(position = position_dodge(width = 0.5)) +
      geom_errorbarh(aes(xmin = lower, xmax = upper), height = 0,
                     position = position_dodge(width = 0.5)) +
      geom_vline(xintercept = 0, linetype = "dashed") +
      labs(x = "Effect size (logit scale)", y = "Covariate",
           title = paste("Posterior β effects:", group_name)) +
      theme_minimal(base_size = 12) +
      theme(legend.position = "bottom"))
  
  ggsave(paste0("Model outputs/", group_name, "_forestPlot.jpg"),
         p_forest, width = 8, height = 6, units = "in", bg = "white")
  
  # Save combined tables
  write.csv(plot_df, paste0("Model outputs/", group_name, "_occResponses.csv"), row.names = FALSE)
  write.csv(beta_df, paste0("Model outputs/", group_name, "_betaSummary.csv"), row.names = FALSE)
  
  message("✅ Finished group: ", group_name)
}
