#################################################################################
### Extract static and dynamic covariates #######################################
#################################################################################

# This file contains code to create a preannotated version of the covariates for 
# the occupancy models. The types of covariates are: 

# * site-level covariates (static). Format: cells x 1 column per each covariate;
# * primary period-level covariates (dynamic). Format: cells x periods per each covariate. 
#       Some of these covariates (e.g. year) will have the repeated values in more than 
#       one column

# Run ONCE but note: this extracts values for cell_IDs present in the WI dataset;
# if you add sites to the dataset, you will need to re-extract the covariates 

# Set workspace -----------------------------------------------------------------
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights/10x10 km spatial layers")
rm(list=ls()); gc()

library(terra)
library(stringr)
library(raster)
library(dplyr)
library(tidyr)
library(lubridate)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(arrow)
library(purrr)
library(parallel)
library(glmnet)
library(mgcv)
library(data.table)
library(ggplot2)


## Set up reference raster ----------------------------------------------------

# Load reference
reference <- rast("raster_100km2_with_cellID.tif")

## If only want covs for study sites -- 

# Limit to cell_IDs present in dataset 
site_cells <- read.csv("WI_loc_matching_cell_ID.csv") 

# Mask reference raster 
reference_sub <- mask(reference, reference %in% site_cells$cell_ID, maskvalues=F) 

## If want all terrestrial areas --

# Get land polygons
land <- ne_countries(scale = "medium", returnclass = "sf")
land_terra <- vect(land)

# Reproject if needed
if (crs(reference) != crs(land_terra)) {
  land_terra <- project(land_terra, crs(reference))
}

# Mask to land
reference_land <- mask(reference, land_terra)

# NOTE some sites not captured in land mask -- add manually 
existing_ids <- reference_land$cell_ID
missing_ids <- setdiff(site_cells$cell_ID, existing_ids)

# Create a raster layer with only the missing site_cells
add_raster <- reference
add_raster[!values(add_raster) %in% missing_ids] <- NA
reference_land <- cover(reference_land, add_raster)

# Create coordinate dataframe 
coords <- as.data.frame(reference, xy=T)


## Create period template -----------------------------------------------------
min_year <- 2000  
max_year <- 2024 
range_year <- c(min_year, max_year)
min_date <- as.Date(paste(range_year[1] - 1, "-12-01", sep = ""))
max_date <- as.Date(paste(range_year[2] + 1, "-03-01", sep = "")) 
start_period <-  seq.Date(min_date, max_date, by =  "91 day") #"3 month"
end_period <-  c(start_period[-1] - 1, NA)

periods <- data.frame(period = paste("Period", seq(1, length(start_period), by = 1), sep = "_"),
                      start_period = start_period, 
                      end_period = end_period) 
periods <- periods[-nrow(periods),]
periods$season <- rep(c("Winter", "Spring", "Summer", "Fall"), length.out = nrow(periods))
periods$year <- year(periods$start_period)
periods$period_counter <- 1:nrow(periods)
head(periods)


## Static layers --------------------------------------------------------------

# Read TIF files for static layers 
static_layers <- list(
  road_dist = rast("roads_100km2.tif"),
  elevation = rast("ele_100km2.tif"),
  tri       = rast("tri_100km2.tif"),
  river_dist= rast("riv_100km2.tif"),
  coeff_var = rast("cv_100km2.tif"),
  cities_lg = rast("humacc_large_100km2.tif"),
  cities_md = rast("humacc_medium_100km2.tif"),
  cities_sm = rast("humacc_small_100km2.tif")
)
r_c <- rast(static_layers)

# Extract cell_IDs
extracted <- terra::zonal(r_c, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 
extracted <- merge(extracted, coords, all.x=T) %>% distinct()

# Extrapolate missing values (using linear models; fills in mean when unable to model)
extracted[] <- lapply(extracted, function(z) { 
  if (is.numeric(z)) { z[is.nan(z)] <- NA_real_ }
  z
})

covariate_cols <- setdiff(names(extracted),  c("cell_ID", "x", "y"))
covariate_cols <- covariate_cols[sapply(extracted[covariate_cols], is.numeric)]

for (cov in covariate_cols) {
  miss <- which(is.na(extracted[[cov]]))
  if (!length(miss)) next  # nothing to fill for this covariate
  
  # training rows (response present and coords present)
  train_rows <- which(!is.na(extracted[[cov]]) & 
                        !is.na(extracted$x) & !is.na(extracted$y))
  if (!length(train_rows)) next  # can't train anything; skip
  
  # candidate numeric predictors (besides the target)
  preds_all <- setdiff(covariate_cols, cov)
  
  # keep predictors that have at least some non-NA and non-zero variance on training data
  good_preds <- preds_all[sapply(preds_all, function(p) {
    v <- extracted[[p]][train_rows]
    any(!is.na(v)) && (is.numeric(v)) && (var(v, na.rm = TRUE) > 0)
  })]
  
  # Full model: cov ~ x + y + good_preds 
  full_predictors <- c("x", "y", good_preds)
  fit_dat_full <- extracted[train_rows, c(cov, full_predictors)]
  fit_dat_full <- fit_dat_full[complete.cases(fit_dat_full), ]
  
  if (nrow(fit_dat_full) >= 5) {
    fit_full <- lm(reformulate(full_predictors, response = cov), data = fit_dat_full)
    
    # predict where all required predictors are present
    can_pred_full <- miss[complete.cases(extracted[miss, full_predictors])]
    if (length(can_pred_full)) {
      extracted[can_pred_full, cov] <- predict(fit_full, newdata = extracted[can_pred_full, ])
      miss <- setdiff(miss, can_pred_full)
    }
  }
  
  # Fallback: cov ~ x + y 
  if (length(miss)) {
    fit_dat_xy <- extracted[train_rows, c(cov, "x", "y")]
    fit_dat_xy <- fit_dat_xy[complete.cases(fit_dat_xy), ]
    if (nrow(fit_dat_xy) >= 3) {
      fit_xy <- lm(as.formula(paste(cov, "~ x + y")), data = fit_dat_xy)
      can_pred_xy <- miss[complete.cases(extracted[miss, c("x","y")])]
      if (length(can_pred_xy)) {
        extracted[can_pred_xy, cov] <- predict(fit_xy, newdata = extracted[can_pred_xy, ])
        miss <- setdiff(miss, can_pred_xy)
      }
    }
  }
  
  # Last resort: fill with column mean  
  if (length(miss)) {
    mu <- mean(extracted[[cov]], na.rm = TRUE)
    extracted[miss, cov] <- mu
  }
}

# Save 
write.csv(extracted, "../Covariates for modelling/site_level_covariates_full.csv", row.names = FALSE)

# Subset site-level covariates
extracted_sub <- extracted[extracted$cell_ID %in% unique(site_cells$cell_ID), ]
write.csv(extracted, "../Covariates for modelling/site_level_covariates.csv", row.names = FALSE)

## Plot to check 
names(extracted)
cov_value <- "cities_lg"

ggplot(extracted, aes(x = x, y = y, fill = .data[[cov_value]])) +
  geom_tile() +   
  scale_fill_viridis_c(option = "magma") +
  coord_equal() +
  theme_minimal()


## Annual dynamic layers ------------------------------------------------------

## Seasonal precipitation -----------------------------------------------------

# Load TIF files 
r_list <- list(precseas_1999 = rast("precseas_2010_100km2.tif"),
               precseas_2011 = rast("precseas_2040_100km2.tif"))
r_stack <- rast(r_list)

# Extract cell_IDs
extracted <- terra::zonal(r_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 

# Reshape and interpolate for 2000–2024
cov_df <- extracted %>%
  pivot_longer(-cell_ID, names_to = "year", values_to = "cov") %>%
  mutate(year = as.numeric(str_remove(year, "precseas_"))) %>%
  group_by(cell_ID) %>%
  summarise(
    start_year = min(year, na.rm = TRUE),
    end_year   = max(year, na.rm = TRUE),
    start_cov  = cov[year == min(year, na.rm = TRUE)],
    end_cov    = cov[year == max(year, na.rm = TRUE)],
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(preds = list({
    if (is.na(start_cov) || is.na(end_cov)) {
      tibble(year = periods$year, cov = NA_real_)
    } else {
      tibble(
        year = periods$year,
        cov  = approx(
          x = c(start_year, end_year),
          y = c(start_cov, end_cov),
          xout = periods$year,
          rule = 2
        )$y
      )
    }
  })) %>%
  unnest(preds) %>%
  ungroup() %>% 
  distinct()

# Expand and pivot 
cov_df <- cov_df %>%
  left_join(periods %>% dplyr::select(year, period_counter), 
            by = "year", relationship = "many-to-many") %>%
  dplyr::select(cell_ID, period_counter, cov) %>%
  pivot_wider(
    id_cols = cell_ID,
    names_from = period_counter,
    values_from = cov,
    values_fill = NA
  ) %>%
  arrange(cell_ID) %>%
  as.matrix()

# Plot to test 
period <- "X67"

plot_df <- cov_df %>%
  dplyr::select(cell_ID, value = all_of(period)) %>%
  left_join(coords, by = "cell_ID")

ggplot(plot_df, aes(x = x, y = y, fill = value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_precseas_full.csv", row.names = F)

# Subset to sites 
sub_cov_df <- cov_df[cov_df$cell_ID %in% site_cells$cell_ID,]
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_precseas_sites.csv", row.names = F)


## Annual precipitation -------------------------------------------------------

# Load TIF files 
r_list <- list(precseas_1999 = rast("annprec_2010_100km2.tif"),
               precseas_2011 = rast("annprec_2040_100km2.tif"))
r_stack <- rast(r_list)

# Extract cell_IDs
extracted <- terra::zonal(r_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 

# Reshape and interpolate for 2000–2024
cov_df <- extracted %>%
  pivot_longer(-cell_ID, names_to = "year", values_to = "cov") %>%
  mutate(year = as.numeric(str_remove(year, "precseas_"))) %>%
  group_by(cell_ID) %>%
  summarise(
    start_year = min(year, na.rm = TRUE),
    end_year   = max(year, na.rm = TRUE),
    start_cov  = cov[year == min(year, na.rm = TRUE)],
    end_cov    = cov[year == max(year, na.rm = TRUE)],
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(preds = list({
    if (is.na(start_cov) || is.na(end_cov)) {
      tibble(year = periods$year, cov = NA_real_)
    } else {
      tibble(
        year = periods$year,
        cov  = approx(
          x = c(start_year, end_year),
          y = c(start_cov, end_cov),
          xout = periods$year,
          rule = 2
        )$y
      )
    }
  })) %>%
  unnest(preds) %>%
  ungroup() %>% 
  distinct()

# Expand and pivot 
cov_df <- cov_df %>%
  left_join(periods %>% dplyr::select(year, period_counter), 
            by = "year", relationship = "many-to-many") %>%
  dplyr::select(cell_ID, period_counter, cov) %>%
  pivot_wider(
    id_cols = cell_ID,
    names_from = period_counter,
    values_from = cov,
    values_fill = NA
  ) %>%
  arrange(cell_ID) %>%
  as.matrix()

# Plot to test 
period <- "X67"

plot_df <- cov_df %>%
  dplyr::select(cell_ID, value = all_of(period)) %>%
  left_join(coords, by = "cell_ID")

ggplot(plot_df, aes(x = x, y = y, fill = value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_annprec_full.csv", row.names = F)

# Subset to sites 
sub_cov_df <- cov_df[cov_df$cell_ID %in% site_cells$cell_ID,]
write.csv(cov_df, ../Covariates for modelling/"primary_occ_covariates_annprec_sites.csv", row.names = F)


## Annual temperature ---------------------------------------------------------

# Load TIF files 
r_list <- list(precseas_1999 = rast("anntemp_2010_100km2.tif"),
               precseas_2011 = rast("anntemp_2040_100km2.tif"))
r_stack <- rast(r_list)

# Extract cell_IDs
extracted <- terra::zonal(r_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 

# Reshape and interpolate for 2000–2024
cov_df <- extracted %>%
  pivot_longer(-cell_ID, names_to = "year", values_to = "cov") %>%
  mutate(year = as.numeric(str_remove(year, "precseas_"))) %>%
  group_by(cell_ID) %>%
  summarise(
    start_year = min(year, na.rm = TRUE),
    end_year   = max(year, na.rm = TRUE),
    start_cov  = cov[year == min(year, na.rm = TRUE)],
    end_cov    = cov[year == max(year, na.rm = TRUE)],
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(preds = list({
    if (is.na(start_cov) || is.na(end_cov)) {
      tibble(year = periods$year, cov = NA_real_)
    } else {
      tibble(
        year = periods$year,
        cov  = approx(
          x = c(start_year, end_year),
          y = c(start_cov, end_cov),
          xout = periods$year,
          rule = 2
        )$y
      )
    }
  })) %>%
  unnest(preds) %>%
  ungroup() %>% 
  distinct()

# Expand and pivot 
cov_df <- cov_df %>%
  left_join(periods %>% dplyr::select(year, period_counter), 
            by = "year", relationship = "many-to-many") %>%
  dplyr::select(cell_ID, period_counter, cov) %>%
  pivot_wider(
    id_cols = cell_ID,
    names_from = period_counter,
    values_from = cov,
    values_fill = NA
  ) %>%
  arrange(cell_ID) %>%
  as.matrix()

# Plot to test 
period <- "X67"

plot_df <- cov_df %>%
  dplyr::select(cell_ID, value = all_of(period)) %>%
  left_join(coords, by = "cell_ID")

ggplot(plot_df, aes(x = x, y = y, fill = value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_temp_full.csv", row.names = F)

# Subset to sites 
sub_cov_df <- cov_df[cov_df$cell_ID %in% site_cells$cell_ID,]
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_temp_sites.csv", row.names = F)


## Warmest season precipitation -----------------------------------------------

# Load TIF files 
r_list <- list(precseas_1999 = rast("precwarm_2010_100km2.tif"),
               precseas_2011 = rast("precwarm_2040_100km2.tif"))
r_stack <- rast(r_list)

# Extract cell_IDs
extracted <- terra::zonal(r_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 

# Reshape and interpolate for 2000–2024
cov_df <- extracted %>%
  pivot_longer(-cell_ID, names_to = "year", values_to = "cov") %>%
  mutate(year = as.numeric(str_remove(year, "precseas_"))) %>%
  group_by(cell_ID) %>%
  summarise(
    start_year = min(year, na.rm = TRUE),
    end_year   = max(year, na.rm = TRUE),
    start_cov  = cov[year == min(year, na.rm = TRUE)],
    end_cov    = cov[year == max(year, na.rm = TRUE)],
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(preds = list({
    if (is.na(start_cov) || is.na(end_cov)) {
      tibble(year = periods$year, cov = NA_real_)
    } else {
      tibble(
        year = periods$year,
        cov  = approx(
          x = c(start_year, end_year),
          y = c(start_cov, end_cov),
          xout = periods$year,
          rule = 2
        )$y
      )
    }
  })) %>%
  unnest(preds) %>%
  ungroup() %>% 
  distinct()

# Expand and pivot 
cov_df <- cov_df %>%
  left_join(periods %>% dplyr::select(year, period_counter), 
            by = "year", relationship = "many-to-many") %>%
  dplyr::select(cell_ID, period_counter, cov) %>%
  pivot_wider(
    id_cols = cell_ID,
    names_from = period_counter,
    values_from = cov,
    values_fill = NA
  ) %>%
  arrange(cell_ID) %>%
  as.matrix()

# Plot to test 
period <- "X67"

plot_df <- cov_df %>%
  dplyr::select(cell_ID, value = all_of(period)) %>%
  left_join(coords, by = "cell_ID")

ggplot(plot_df, aes(x = x, y = y, fill = value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_warmseas_full.csv", row.names = F)

# Subset to sites 
sub_cov_df <- cov_df[cov_df$cell_ID %in% site_cells$cell_ID,]
write.csv(cov_df, "../Covariates for modelling/primary_occ_covariates_warmseas_sites.csv", row.names = F)


## Global world population (GPW) ----------------------------------------------

# Load TIF files 
gwp_stack <- rast(list.files("GWP", full.names = TRUE))

# Extract cell_IDs
extracted <- terra::zonal(gwp_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE)
head(extracted)

# Pivot long 
df_long <- extracted %>%
  pivot_longer(cols = -cell_ID,
               names_to = "year",
               values_to = "cov_value") %>%
  mutate(year = as.integer(sub("GPW_", "", year)))

# Add x & y coordinates
coords <- as.data.frame(reference, xy=T)
df_long <- merge(df_long, coords, all.x=T) 

# Fit a smooth GAM model over space (x, y) and time (year)
model <- gam(cov_value ~ s(x, y) + s(year, k=5),
             data = df_long, na.action = na.exclude)

# Make a full grid for prediction
all_years <- c(1999, 2001:2004, 2006:2009, 2011:2014, 2016:2019, 2021:2024)
newdata <- expand.grid(
  cell_ID = unique(df_long$cell_ID),
  year = all_years
)

missing_vals <- df_long[is.na(df_long$cov_value),] %>% 
  dplyr::select(-cov_value)
df_long <- df_long[!is.na(df_long$cov_value),]

newdata <- merge(newdata, coords, all.x=T) 
newdata <- rbind(newdata, missing_vals)

# Predict missing + new years
newdata$cov_value <- predict(model, newdata = newdata)

# Combine
df_long_combo <- rbind(df_long, newdata) %>%   
  dplyr::select(-c(x,y)) %>% 
  left_join(periods, relationship = "many-to-many") %>% 
  dplyr::select(-c(period, start_period, end_period, season))

# Pivot
df_mat <- df_long_combo %>% 
  pivot_wider(id_cols = cell_ID, names_from = period_counter, values_from = cov_value, values_fill = NA) %>%
  arrange(cell_ID) %>%
  dplyr::select(cell_ID, order(as.numeric(names(.)[-1])) + 1) %>% 
  as.matrix()

# Plot to check 
plot_df <- df_long_combo %>%  left_join(coords, by = "cell_ID")

selected_year <- "2007"
plot_subset <- plot_df %>% filter(year == selected_year)

ggplot(plot_subset, aes(x = x, y = y, fill = cov_value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe
write.csv(df_mat, "../Covariates for modelling/primary_occ_covariates_GPW_full.csv", row.names = F)

# Subset to sites  
sub_cov_df <- df_mat[df_mat[, "cell_ID"] %in% site_cells$cell_ID, ]
write.csv(sub_cov_df, "../Covariates for modelling/primary_occ_covariates_GPW_sites.csv", row.names = F)


## 
# Load TIF files 
gwp_stack <- rast(list.files("10x10 km spatial layers/GWP", full.names = TRUE))

# Extract cell_IDs
extracted <- terra::zonal(gwp_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE)
head(extracted)

# Pivot long 
df_long <- extracted %>%
  pivot_longer(cols = -cell_ID,
               names_to = "year",
               values_to = "cov_value") %>%
  mutate(year = as.integer(sub("GPW_", "", year)))

# Add x & y coordinates
coords <- as.data.frame(reference_land, xy=T)
df_long <- merge(df_long, coords, all.x=T) 

# Fit a smooth GAM model over space (x, y) and time (year)
library()
model <- gam(cov_value ~ s(x, y) + s(year, k=5),
             data = df_long, na.action = na.exclude)

# Make a full grid for prediction
all_years <- c(1999, 2001:2004, 2006:2009, 2011:2014, 2016:2019, 2021:2024)
newdata <- expand.grid(
  cell_ID = unique(df_long$cell_ID),
  year = all_years
)

missing_vals <- df_long[is.na(df_long$cov_value),] %>% 
  dplyr::select(-cov_value)
df_long <- df_long[!is.na(df_long$cov_value),]

newdata <- merge(newdata, coords, all.x=T) 
newdata <- rbind(newdata, missing_vals)

# Predict missing + new years
newdata$cov_value <- predict(model, newdata = newdata)

# Combine
df_long_combo <- rbind(df_long, newdata) %>%
  dplyr::select(-c(x, y)) %>% 
  arrange(cell_ID, year)

write.csv(df_long_combo, "gwp_long_interpolated")

## Enhanced vegetation index (EVI) --------------------------------------------

# Load TIF files 
evi_files <- list.files("EVI", full.names = TRUE)
evi_list_raster <- lapply(evi_files, rast)
evi_stack <- rast(evi_list_raster)
names(evi_stack) <- gsub(".{11}$", "", basename(evi_files))

# Extract mean values for each cell_ID across all rasters in the stack
extracted <- terra::zonal(evi_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE) 
extracted <- as.data.table(extracted)
head(extracted)

# Convert to long
dt_long <- melt(extracted,
                id.vars = "cell_ID",
                variable.name = "date",
                value.name = "cov_value")
dt_long[, c("year", "doy") := tstrsplit(gsub("evi_", "", date), "_", fixed = TRUE)]
dt_long[, year := as.integer(year)]
dt_long[, doy  := as.integer(doy)]
dt_long[, obs_date := as.Date(doy - 1, origin = paste0(year, "-01-01"))]
dt_long[, date := NULL]

# Match with periods 
dt_long[, obs_start := as.IDate(obs_date)]
dt_long[, obs_end   := as.IDate(obs_date)]   
dt_long_test <- dt_long %>% select(-doy)
setcolorder(dt_long_test, c("obs_start", "obs_end", setdiff(names(dt_long_test), c("obs_start","obs_end"))))

periods <- as.data.table(periods)
periods[, start_period := as.IDate(start_period)]
periods[, end_period   := as.IDate(end_period)]
periods_test <- periods %>% select(-season, -period)

setkey(periods_test, start_period, end_period)
setkey(dt_long_test, obs_start, obs_end)

dt_long_test <- foverlaps(
  dt_long_test,     # y table
  periods_test,     # x table
  by.x = c("obs_start", "obs_end"),
  by.y = c("start_period", "end_period"),
  type = "within",  # only matches where obs_date is inside the period
  nomatch = NA     # keep unmatched rows as NA
)
dt_long_test <- dt_long_test %>% select(period_counter, year, cell_ID, cov_value)

dt_period <- dt_long_test[, .(
  cov_value = mean(cov_value, na.rm = TRUE)
), by = .(cell_ID, period_counter, year)]

save <- dt_period

# Ensure one row per cell_ID per period 
all_ids <- dt_period[, unique(cell_ID)]
all_periods <- unique(periods[, .(period_counter)])

# Use cross join with CJ() safely
full_grid <- CJ(cell_ID = unique(dt_period$cell_ID),        
                period_counter = unique(periods$period_counter))

# Add data
dt_complete <- merge(full_grid, dt_period,
                     by = c("cell_ID", "period_counter"),
                     all.x = TRUE)
dt_complete <- dt_complete[!is.na(dt_complete$cell_ID),]

head(dt_complete)
write.csv(dt_complete, "evi_save.csv", row.names=F)

periods[periods$period_counter == 55,]
dt_complete[dt_complete$period_counter == 55,]$year <- 2013
#I don't know why this doesn't just work...
dt_complete[is.na(dt_complete$year),] 

# Add coordinates
coords_dt <- as.data.table(coords)
dt_complete <- coords_dt[dt_complete, on = "cell_ID"]

# Ridge regression imputation per year
impute_ridge_by_year <- function(dt) {
  dt[, cov_value := as.numeric(cov_value)]
  
  dt_imputed <- dt[, {
    this <- copy(.SD)   # make a modifiable copy
    train <- this[!is.na(cov_value) & !is.nan(cov_value)]
    
    if (nrow(train) >= 3 && length(unique(train$cov_value)) > 1) {
      # design matrices
      X_train <- model.matrix(~ period_counter + x + y, train)[, -1]
      y_train <- train$cov_value
      
      fit <- cv.glmnet(
        X_train, y_train,
        alpha = 0,
        nfolds = min(5, nrow(train)),
        standardize = TRUE
      )
      
      X_all <- model.matrix(~ period_counter + x + y, this)[, -1]
      preds <- as.numeric(predict(fit, newx = X_all, s = "lambda.min"))
      
      # replace only missing
      this$cov_value <- fifelse(is.na(this$cov_value) | is.nan(this$cov_value),
                                preds, this$cov_value)
    }
    
    this  # return updated data.table for this group
  }, by = year]
  
  return(dt_imputed[])
}

dt_imputed <- impute_ridge_by_year(dt_complete)

# Pivot to final matrix
setkey(dt_imputed, cell_ID, period_counter)
EVI_mat <- dcast(
  dt_imputed,
  cell_ID ~ period_counter,
  value.var = "cov_value",
  fill = NA_real_
)

head(EVI_mat)

# Plot to check
selected_year <- "2007"
plot_subset <- dt_imputed %>% filter(year == selected_year)

ggplot(plot_subset, aes(x = x, y = y, fill = cov_value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe --- DO THIS! 
write.csv(EVI_mat, "../Covariates for modelling/primary_occ_covariates_EVI_full.csv", row.names = F)

# Subset to sites --- DO THIS! 
subset_mat <- EVI_mat[EVI_mat$cell_ID %in% site_cells$cell_ID, ]
write.csv(subset_mat, "../Covariates for modelling/primary_occ_covariates_EVI_sites.csv", row.names = F)


## For pipeline

library(data.table)
library(terra)
library(zoo)        # for na.approx (linear interpolation)
library(lubridate)

# Read reference 
reference_land <- rast("10x10 km spatial layers/raster_100km2_with_cellID_terrestrial.tif")

# Load TIF files
evi_files <- list.files("10x10 km spatial layers/EVI", full.names = TRUE)
evi_list_raster <- lapply(evi_files, rast)
evi_stack <- rast(evi_list_raster)
names(evi_stack) <- gsub(".{11}$", "", basename(evi_files))

# Extract mean values for each cell_ID
extracted <- terra::zonal(evi_stack, reference_land, fun = mean, na.rm = TRUE, df = TRUE)
extracted <- as.data.table(extracted)

# Convert to long format with proper date
dt_long <- melt(extracted,
                id.vars = "cell_ID",
                variable.name = "date_str",
                value.name = "cov_value")
setDT(dt_long)
dt_long[, c("year", "doy") := tstrsplit(gsub("evi_", "", date_str), "_", fixed = TRUE)]
dt_long[, year := as.integer(year)]
dt_long[, doy := as.integer(doy)]
dt_long[, obs_date := as.Date(doy - 1, origin = paste0(year, "-01-01"))]
dt_long[, date_str := NULL]

## Create full periods template
min_year <- 2000  
max_year <- 2024 
range_year <- c(min_year, max_year)
min_date <- as.Date(paste(range_year[1] - 1, "-12-01", sep = ""))
max_date <- as.Date(paste(range_year[2] + 1, "-03-01", sep = "")) 
start_period <-  seq.Date(min_date, max_date, by =  "91 day") #"3 month"
end_period <-  c(start_period[-1] - 1, NA)

periods <- data.frame(period = paste("Period", seq(1, length(start_period), by = 1), sep = "_"),
                      start_period = start_period, 
                      end_period = end_period) 
periods <- periods[-nrow(periods),]
periods$season <- rep(c("Winter", "Spring", "Summer", "Fall"), length.out = nrow(periods))
periods$year <- year(periods$start_period)
periods$period_counter <- 1:nrow(periods)
head(periods)

# Match each observation date to its 91-day period
periods_dt <- as.data.table(periods)[, .(start_period, end_period, year, season)]

# Use foverlaps to assign period info to each observation
setkey(dt_long, obs_date, obs_date)
setkey(periods_dt, start_period, end_period)

dt_with_period <- dt_long[
  periods_dt,
  on = .(obs_date >= start_period, obs_date <= end_period),
  .(cell_ID, cov_value, obs_date, year = i.year, season = i.season),
  nomatch = NULL  
]

# Keep only relevant columns
dt_with_period <- dt_with_period[, .(cell_ID, year, season, cov_value)]

# Aggregate: mean EVI per cell × period (in case multiple rasters fall in one period)
dt_period <- dt_with_period[
  , .(cov_value = mean(cov_value, na.rm = TRUE)),
  by = .(cell_ID, year, season)
]

# Create full grid: every cell_ID × every period (year + season)
full_grid <- CJ(
  cell_ID = unique(dt_period$cell_ID),
  year = unique(periods$year),
  season = unique(periods$season)
)

# Merge to ensure one row per cell × period
dt_full <- merge(full_grid, dt_period, 
                 by = c("cell_ID", "year", "season"), 
                 all.x = TRUE)

# Linear interpolation within each cell_ID over time
# Order periods chronologically (assuming season order: Winter → Spring → Summer → Fall)
season_order <- c("Spring", "Summer", "Fall", "Winter")
dt_full[, season_factor := factor(season, levels = season_order)]
dt_full <- dt_full[order(cell_ID, year, season_factor)]

# Interpolate missing cov_value within each cell_ID
dt_imputed <- dt_full[
  , cov_value := na.approx(cov_value, na.rm = FALSE, rule = 2),   
  by = cell_ID
]

# Final clean-up
dt_final <- dt_imputed[, .(cell_ID, year, season, cov_value)]
dt_final <- dt_final[order(cell_ID, year, season_factor)]

# Remove helper column
dt_final[, season_factor := NULL]

# Save if desired
fwrite(dt_final, "10x10 km spatial layers/evi_long_interpolated.csv", row.names=F)




## Global Forest Cover (GFC) --------------------------------------------------

# Load TIF files 2001:2021 (NOTE: don't have the 2013 raster - download when can)
gfc_files <- list.files("../Raw spatial layers/GFC", full.names = TRUE)
gfc_list_raster <- lapply(gfc_files, rast)
gfc_stack <- rast(gfc_list_raster)

# Align and extract GFC values 
gfc_stack_aligned <- project(gfc_stack, reference_land, method = "near")
extracted <- terra::zonal(gfc_stack_aligned, reference_land, fun = mean, na.rm = TRUE, df = TRUE)
head(extracted)

# Format data frame 
df_long <- extracted %>%
  pivot_longer(
    cols = starts_with("GFC_"),
    names_to = "date",
    values_to = "GFC") %>%
  mutate(year = str_extract(date, "\\d{4}") %>% as.integer())

# Add x & y coordinates
coords <- as.data.frame(reference, xy=T)
df_long <- merge(df_long, coords, all.x=T) %>% 
  dplyr::select(-date) %>% 
  rename(cov_value = GFC)

# Fit GAM: smooth in x, y, and year
gam_model <- gam(cov_value ~ s(x, y) + s(year), data = df_long, na.action = na.exclude)

# Ensure all cell_ids have all years 
df_filled <- df_long %>%
  group_by(cell_ID) %>%
  complete(year = setdiff(2001:2021, 2013)) %>%
  ungroup()

# Create prediction df for 1999:2000, 2013, 2022:2024 and for missing data 
newdata <- expand.grid(
  cell_ID = unique(df_filled$cell_ID),
  year = c(1999:2000, 2013, 2022:2024)
)

missing_vals <- df_filled[is.na(df_filled$cov_value),] %>% 
  dplyr::select(-cov_value, -x, -y)
df_filled <- df_filled[!is.na(df_filled$cov_value),]

newdata <- rbind(newdata, missing_vals)
newdata <- merge(newdata, coords, by = "cell_ID", all.x = TRUE)

# Predict missing + new years
newdata$cov_value <- predict(gam_model, newdata = newdata)
head(newdata)

# Format 
df_long_combo <- rbind(df_filled, newdata) %>% 
  mutate(year = as.integer(year)) %>% 
  dplyr::select(-c(x,y))

GFC_joined <- df_long_combo %>%
  left_join(periods, relationship = "many-to-many") %>% 
  dplyr::select(cell_ID, period_counter, cov_value) 

df_wide <- GFC_joined %>%
  pivot_wider(
    id_cols = cell_ID,
    names_from = period_counter,
    values_from = cov_value
  ) %>%
  arrange(cell_ID) %>%
  dplyr::select(cell_ID, order(as.numeric(names(.)[-1])) + 1) %>% 
  as.matrix()

head(df_wide)

# Plot to check  
selected_period <- 1
plot_subset <- GFC_joined %>% filter(period_counter == selected_period) %>% 
  left_join(coords, by = "cell_ID")

ggplot(plot_subset, aes(x = x, y = y, fill = cov_value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(df_wide, "../Covariates for modelling/primary_occ_covariates_GFC_full.csv") 

# Subset to sites
subset_mat <- df_wide[df_wide[, 1] %in% site_cells$cell_ID, ]
write.csv(subset_mat, "../Covariates for modelling/primary_occ_covariates_GFC_sites.csv")


## Proportion crop/urban ------------------------------------------------------

# Read crop file 
crop <- read.csv("crop_proportion_all_years_full_new.csv") %>% 
  filter(year %in% periods$year) %>% 
  rename(cov_value = crop_prop) %>% 
  distinct()

CROP_joined <- crop %>%
  left_join(periods, relationship = "many-to-many") %>% 
  dplyr::select(cell_ID, period_counter, cov_value) %>% 
  pivot_wider(id_cols = cell_ID, names_from = period_counter, values_from = cov_value, 
              values_fill = NA) %>%
  arrange(cell_ID) %>% 
  as.matrix()

# Plot to check  
selected_year <- 1999

plot_subset <- crop %>% filter(year == selected_year) 
ggplot(plot_subset, aes(x = x, y = y, fill = cov_value)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(CROP_joined, "../Covariates for modelling/primary_occ_covariates_crop_full.csv", row.names=F)

# Subset to sites 
subset_mat <- CROP_joined[CROP_joined[, "cell_ID"] %in% site_cells$cell_ID,]
write.csv(subset_mat, "../Covariates for modelling/primary_occ_covariates_crop_sites.csv", row.names=F)

## Read urban file 
urban <- read.csv("urban_proportion_all_years.csv") %>% 
  filter(year %in% periods$year) %>% 
  rename(cov_value = proportion) %>% 
  distinct()

URBAN_joined <- urban %>%
  left_join(periods, relationship = "many-to-many") %>% 
  dplyr::select(cell_ID, period_counter, cov_value) %>% 
  pivot_wider(id_cols = cell_ID, names_from = period_counter, values_from = cov_value, 
              values_fill = NA) %>%
  arrange(cell_ID) %>% 
  as.matrix()

write.csv(URBAN_joined, "primary_occ_covariates_urban.csv", row.names=F)


## Proportion of cell in protected area (WDPA) --------------------------------

# Read WDPA file  
wdpa <- read.csv("prop_wdpa_full.csv")

WDPA_joined <- wdpa %>%
  left_join(periods, relationship = "many-to-many") %>% 
  dplyr::select(cell_ID, period_counter, prop_in_PA) %>% 
  pivot_wider(id_cols = cell_ID, names_from = period_counter, values_from = prop_in_PA, 
              values_fill = NA) %>%
  arrange(cell_ID) %>% 
  as.matrix()

head(WDPA_joined)

# Plot to check  
selected_year <- 2006
plot_subset <- wdpa %>% filter(year == selected_year) %>% 
  left_join(coords, by = "cell_ID")

ggplot(plot_subset, aes(x = x, y = y, fill = prop_in_PA)) +
  geom_tile() + scale_fill_viridis_c(option = "magma") +
  coord_equal() + theme_minimal()

# Save full dataframe 
write.csv(WDPA_joined, "../Covariates for modelling/primary_occ_covariates_WDPA_full.csv", row.names=F)

# Subset to sites 
head(WDPA_joined)
subset_mat <- WDPA_joined[WDPA_joined[, "cell_ID"] %in% site_cells$cell_ID, ]
write.csv(subset_mat, "../Covariates for modelling/primary_occ_covariates_WDPA_sites.csv", row.names=F)
