##########################
##### Model Results ######
##########################

## Set workspace --------------------------------------------------------------
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights")
rm(list=ls()); gc()
set.seed(123)

# Load libraries
library(tidyterra)
library(tidyverse)
library(tidyr)
library(terra)
library(spOccupancy)
library(coda)
library(stringr)
library(ggplot2)
library(rasterVis)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
#library(gganimate)
library(dplyr)
library(purrr)


## Load and format WI data (for all) ------------------------------------------

# Load data 
overview_seq <- read.csv("WI data/sequences_updated_20240710.csv")
overview_images <- read.csv("WI data/images_updated_20240714.csv")

# Format data
dat_seq <- overview_seq |>
  mutate(record_date = sequence_date) |>
  dplyr::select(-c(sequence_date, sequence_datetime)) |>
  collect()

# if loaded csv: 
dat_seq <- dat_seq %>%
  dplyr::select(project_id, deployment_location_id, record_date, sensor_start_date_and_time, 
                sensor_end_date_and_time, latitude, longitude, class, sp_binomial)

dat_images <- overview_images |>
  mutate(record_date = photo_date) |>
  mutate(sp_binomial = Accepted_MOL) |>
  dplyr::select(-c(photo_date, photo_datetime, Accepted_MOL)) |>
  collect()

dat_images <- dat_images[!dat_images$sp_binomial == "Accepted_MOL",] |> #header added as row
  mutate(latitude = as.numeric(latitude)) |>
  mutate(longitude = as.numeric(longitude)) 

# if loaded csv: 
dat_images <- dat_images %>% 
  dplyr::select(project_id, deployment_location_id, record_date, sensor_start_date_and_time, 
                sensor_end_date_and_time, latitude, longitude, class, sp_binomial)

# Combine data 
all_dat <- rbind(dat_images, dat_seq) %>% 
  mutate(sensor_start_date = as.Date(sensor_start_date_and_time),
         sensor_end_date = as.Date(sensor_end_date_and_time),
         record_date = as.Date(record_date)) %>% 
  dplyr::select(-c(sensor_start_date_and_time, sensor_end_date_and_time))

all_dat <- all_dat[!is.na(all_dat$record_date),] 

rm(dat_seq, dat_images, overview_images, overview_seq)


## Load species model outputs -------------------------------------------------

(filenames <- list.files("Model outputs", full.names = TRUE))
species <- "Acinonyx jubatus"

# Model outputs 
file_species <- gsub(" ", "_", species)
file_path <- filenames[grep(file_species, filenames)]
filename <- paste0(file_path, "/", file_species, "_svcTPGOcc.RData")
load(filename)

# MOL range maps 
mmd_map_path <- paste("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/", file_species, ".tif", sep="")
mmd_map <- rast(mmd_map_path)


## Results --------------------------------------------------------------------

## Basic summary
summary(out)

## Parameter plots: Occurrence 
occ.samps <- out$beta.samples 
occ_quantiles <- as.data.frame(matrix(NA, ncol(occ.samps), 6)) 
colnames(occ_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
occ_quantiles$covariate <- colnames(occ.samps)
occ_quantiles$covariate <- c("Intercept", "Crop", "GPW", "Precip", "WDPA", "EVI", "GFC", "Road Dist", "TRI", "River Dist", "CV", "City Dist", "Trend") #update as appropriate 
desired_order <- c("TRI", "Road Dist", "River Dist", "City Dist", "CV",
                   "Crop", "GPW", "Precip", "WDPA", "EVI", "GFC", "Trend", "Intercept")
occ_quantiles$covariate <- factor(occ_quantiles$covariate, levels = desired_order)
occ_quantiles$mean <- colMeans(occ.samps)
occ_quantiles[,3:6] <- t(apply(occ.samps, 2, quantile, probs = c(0.025, 0.25, 0.75, 0.975)))

(occParams <- ggplot(occ_quantiles, aes(x = covariate, y = mean)) +
    geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
    geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                  linewidth = 1.5, show.legend = FALSE) +
    geom_point() +
    theme_bw() +
    geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
    xlab('Covariates (scaled)') +
    ylab('Posterior Distribution') +
    labs(title = "Occurrence coefficients", 
         subtitle = bquote(italic(.(target_species)))) + 
    coord_flip())

file_name <- paste(file_path, "/", target_species, "_occurrenceParams.jpg", sep="")
ggsave(filename = file_name, plot = occParams, width = 6, height = 5, units = "in")

## Parameter plots: Detection 
det.samps <- out$alpha.samples
det_quantiles <- as.data.frame(matrix(NA, ncol(det.samps), 6))
colnames(det_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
det_quantiles$covariate <- colnames(det.samps)
det_quantiles$covariate <- c("Intercept", "Effort", "Julian Day", "Julian Day Sq", "N. Depl") #update as appropriate
desired_order <- c("Effort", "N. Depl", "Julian Day", "Julian Day Sq", "Intercept")
det_quantiles$covariate <- factor(det_quantiles$covariate, levels = desired_order)
det_quantiles$mean <- colMeans(det.samps)
det_quantiles[,3:6] <- t(apply(det.samps ,2,quantile,probs=c(0.025, 0.25, 0.75, 0.975)))

(detParams <- ggplot(det_quantiles, aes(x = covariate, y = mean)) +
    geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
    geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                  linewidth = 1.5, show.legend = FALSE) +
    geom_point() +
    theme_bw() +
    geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
    xlab('Covariates (scaled)') +
    ylab('Posterior Distribution') +
    labs(title = "Detection coefficients", 
         subtitle = bquote(italic(.(target_species)))) + 
    coord_flip())

file_name <- paste(file_path, "/", target_species, "_detectionParams.jpg", sep="")
ggsave(filename = file_name, plot = detParams, width = 6, height = 3, units = "in")

# -> Interpretations:
#      - Coefficients are estimated for the logit(ψ) = βX model and thus must be 
#        interpreted on the logit scale
#      - Positive beta coefficents imply that an increase in the value of that 
#        covariate results in an increase in the probability of occurrence, when
#        all other covariate values are held constant.
#      - Negative beta coefficents imply that an increase in the value of that 
#        covariate results in a decrease in the probability of occurrence, when 
#        all other covariate values are held constant.


## Occupancy probabilities across periods -------------------------------------

# This plot shows the average occupancy probability across all 373 sites within
# each period. The black points/lines are the medians and the shaded regions are 
# the 95% Bayesian CIs. 

# Parametners 
unique.periods <- as.numeric(gsub("p", "", dimnames(out$y)[[2]])) #unique periods
n.periods <- length(unique.periods) #number of periods 

# Average occupancy prob in each period across all sites
psi.mean.samples <- apply(out$psi.samples, c(1, 3), mean) 
psi.medians <- apply(psi.mean.samples, 2, median) #medians per period 
psi.quants <- apply(psi.mean.samples, 2, quantile, c(0.025, 0.975)) #95% Bayesian CIs

# Data frame for plotting in ggplot
plot.df <- data.frame(periods = unique.periods,
                      med = psi.medians,
                      low = c(psi.quants[1, ]),
                      high = c(psi.quants[2, ]))

# Format date breaks 
period_dates <- periods %>%
  mutate(month = case_when(
    season == "Winter" ~ 1,
    season == "Spring" ~ 4,
    season == "Summer" ~ 7,
    season == "Fall"   ~ 10),
    period_date = ymd(paste(year, month, "01", sep = "-")),
    label_year = ifelse(month == 4, as.character(year), "")) %>% 
  rename(periods = period_counter)

plot.df <- plot.df %>%
  left_join(period_dates, by = "periods") %>%
  dplyr::select(period_date, med, low, high, label_year)

# Plot
(occPeriods <- ggplot() +
    geom_ribbon(data = plot.df, aes(x = period_date, ymin = low, ymax = high),
                fill = 'darkorchid4', alpha = 0.3) +
    geom_line(data = plot.df, aes(x = period_date, y = med), lineend = 'butt') +
    geom_point(data = plot.df, aes(x = period_date, y = med)) +
    theme_bw(base_size = 14) +
    theme(legend.position = c(0.75, 0.125)) +
    scale_y_continuous(limits = c(0, 1)) +
    labs(x = "Date", y = 'Average Occupancy Probability', 
         title = "Occupancy through time", 
         subtitle = bquote(italic(.(target_species)))))

file_name <- paste(file_path, "/", target_species, "_occAcrossPeriods.jpg", sep="")
ggsave(filename = file_name, plot = occPeriods, width = 7, height = 4, units = "in")


## Predictions ----------------------------------------------------------------

# Species detections 
dat_sp <- all_dat %>% filter(sp_binomial == target_species) %>% 
  dplyr::select(latitude, longitude) %>% 
  distinct()
plot_sp_coords <- st_as_sf(dat_sp, coords = c("longitude", "latitude"), crs = 4326)
plot_sp_coords_proj <- st_transform(plot_sp_coords, crs = st_crs(ref))

# Load and format reference  
ref <- rast("10x10 km spatial layers/raster_100km2_with_cellID.tif")
world <- ne_countries(scale = "medium", returnclass = "sf")

# Get bounding box for all sites in range or with species detections
plot_coords <- as.data.frame(coords) 
crs <- crs(ref)
plot_coords_sf <- st_as_sf(plot_coords, coords = c("x", "y"), crs = crs)  
bbox_detect <- st_bbox(plot_coords_sf)

# get bounding box for expert range maps 
bbox_mmd <- st_bbox(mmd_map)

# union of both bboxes (whichever is larger)
bbox_union <- st_bbox(
  c(xmin = min(bbox_detect["xmin"], bbox_mmd["xmin"]),
    ymin = min(bbox_detect["ymin"], bbox_mmd["ymin"]),
    xmax = max(bbox_detect["xmax"], bbox_mmd["xmax"]),
    ymax = max(bbox_detect["ymax"], bbox_mmd["ymax"])),
  crs = st_crs(ref)
)

# crop world to union bbox
crs_union <- st_crs(ref)
world_proj <- st_transform(world, crs_union)
world_cropped <- st_crop(world_proj, bbox_union)

# Plot detection sites ----
world <- ne_countries(scale = "medium", returnclass = "sf")
world <- st_transform(world, crs = crs)

# Plot
ggplot() + 
  geom_sf(data = world, fill = "gray90", color = "gray60", linewidth = 0.3) +
  geom_spatraster(data = mmd_map) + 
  geom_sf(data = plot_coords_sf, color = "#ece7f2", size = 2) + 
  geom_sf(data = plot_sp_coords_proj, color = "#2b8cbe", size = 2) +  
  scale_fill_viridis_c(na.value = NA) +
  theme_minimal() + 
  theme(legend.position = "none") + 
  labs(title = "Species Detection Sites")

# Plot zoomed to bbox  
(speciesDet <- ggplot() +
    geom_sf(data = world_cropped, fill = "gray90", color = "gray60") +
    geom_spatraster(data = mmd_map) + 
    geom_sf(data = plot_coords_sf, shape = 1, size = 2, alpha = 0.5) +           
    geom_sf(data = plot_sp_coords_proj, shape = 16, size = 2, color = "violet") + 
    scale_fill_viridis_c(na.value = NA) +
    theme_minimal() + theme(legend.position = "none") + 
    labs(title = "Species Detection Sites [Zoomed]", 
         subtitle = bquote(italic(.(as.name(target_species))))))

file_name <- paste(file_path, "/", target_species, "_speciesDetections.jpg", sep="")
ggsave(filename = file_name, plot = speciesDet, width = 6, height = 5, units = "in")


# Crop to get cell_IDs within MMD ---------------------------------------------

ref <- rast("10x10 km spatial layers/raster_100km2_with_cellID.tif")
mmd_repro <- project(mmd_map, ref)
masked_ref <- mask(ref, mmd_repro)
plot(masked_ref)
mmd_cellIDs <- unique(masked_ref$cell_ID) #for some reason, one that is not in covs 


# Format static covs ----------------------------------------------------------

static_covs <- read.csv("Covariates for modelling/site_level_covariates_full.csv") %>% 
  dplyr::select(-c(cities_md, cities_sm)) %>% 
  filter(cell_ID %in% mmd_cellIDs$cell_ID)

road_dist.0 <- static_covs$road_dist
tri.0 <- static_covs$tri
river_dist.0 <- static_covs$river_dist 
coeff_var.0 <- static_covs$coeff_var 
cities_lg.0 <- static_covs$cities_lg 


# Format dynamic covariates ---------------------------------------------------

primary.periods <- seq(min(covs$period_counter), max(covs$period_counter), by = 1)

# Extraction function
cov_subset <- function(cov_dataframe_name, primary.periods, cell_IDs){
  covariate <- read.csv(cov_dataframe_name) %>% 
    dplyr::select(-any_of("X")) %>% 
    filter(cell_ID %in% cell_IDs) %>% 
    arrange(cell_ID)
  cols <- grep(
    paste0("^X(", paste(primary.periods, collapse = "|"), ")$"),
    names(covariate),
    value = TRUE
  )
  cols <- cols[order(as.numeric(sub("X", "", cols)))]
  covariate <- covariate %>% 
    select(all_of(cols)) %>% 
    as.matrix() 
  return(covariate)
}

# Processed values 
crop.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_crop_full.csv", primary.periods, mmd_cellIDs$cell_ID) 
evi.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_EVI_full.csv", primary.periods, mmd_cellIDs$cell_ID)
gpw.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_GPW_full.csv", primary.periods, mmd_cellIDs$cell_ID)
precseas.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_precseas_full.csv", primary.periods, mmd_cellIDs$cell_ID)
wdpa.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_WDPA_full.csv", primary.periods, mmd_cellIDs$cell_ID) 
gfc.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_GFC_full.csv", primary.periods, mmd_cellIDs$cell_ID)
trend.0 <- matrix(rep(primary.periods, each = nrow(static_covs)),
                  nrow = nrow(static_covs),
                  ncol = length(primary.periods),
                  byrow = FALSE)
colnames(trend.0) <- as.character(primary.periods)


## Create prediction design matrix (1 = intercept) ----------------------------

# Parameters
n.sites <- nrow(static_covs)            # number of sites 
n.periods <- length(primary.periods)    # number ofyears 
n.beta <- ncol(out$beta.samples)        # number of occupancy parameters 

coords.0 <- static_covs[,c("x","y")] %>% distinct() %>% as.matrix()

# Create and fill an array with the proper dimensions
X.0 <- array(NA, dim = c(n.sites, n.periods, n.beta))
X.0[, , 1] <-  1
X.0[, , 2] <-  (crop.0 - mean(dat_ls$occ.covs$crop))/sd(dat_ls$occ.covs$crop)
X.0[, , 3] <-  (gpw.0 - mean(dat_ls$occ.covs$gpw))/sd(dat_ls$occ.covs$gpw)
X.0[, , 4] <-  (precseas.0 - mean(dat_ls$occ.covs$precseas))/sd(dat_ls$occ.covs$precseas)
X.0[, , 5] <-  (wdpa.0 - mean(dat_ls$occ.covs$wdpa))/sd(dat_ls$occ.covs$wdpa)
X.0[, , 6] <-  (evi.0 - mean(dat_ls$occ.covs$evi))/sd(dat_ls$occ.covs$evi)
X.0[, , 7] <-  (gfc.0 - mean(dat_ls$occ.covs$gfc))/sd(dat_ls$occ.covs$gfc)
X.0[, , 8] <-  (road_dist.0 - mean(dat_ls$occ.covs$road_dist))/sd(dat_ls$occ.covs$road_dist)   
X.0[, , 9] <-  (tri.0 - mean(dat_ls$occ.covs$tri))/sd(dat_ls$occ.covs$tri)            
X.0[, , 10] <- (river_dist.0 - mean(dat_ls$occ.covs$river_dist))/sd(dat_ls$occ.covs$river_dist)     
X.0[, , 11] <- (coeff_var.0 - mean(dat_ls$occ.covs$coeff_var))/sd(dat_ls$occ.covs$coeff_var)      
X.0[, , 12] <- (cities_lg.0 - mean(dat_ls$occ.covs$cities_lg))/sd(dat_ls$occ.covs$cities_lg)      
X.0[, , 13] <- (trend.0 - mean(dat_ls$occ.covs$trend))/sd(dat_ls$occ.covs$trend)

# Give names to X.0 just to make things clear
dimnames(X.0)[[3]] <- c('(Intercept)', 'Crop', 'GPW', 'Precip', 'WDPA', 'EVI', 'GFC', 'Road Dist', 'TRI', 'River Dist', 'Coef Var', 'Cities Dist', 'Periods') 

## Predict occupancy for all years --------------------------------------------

## Regular predict ----
#start_time <- Sys.time()
#out.pred <- predict(out, X.0, coords.0, t.cols = 1:n.periods, ignore.RE = TRUE, type = 'occupancy')
#end_time <- Sys.time()
#end_time - start_time 
#str(out.pred)

# Calculate mean occupancy probability for each site/year: 
#psi.means <- apply(out.pred$psi.0.samples, c(2, 3), mean)

## For extremely large datasets, chunk the predictions ---- 
chunked_predict_from_betas <- function(model, X.0, coords.0, t.cols,
                                       chunk_size = 2000,
                                       n_post_draws = NULL,     
                                       n_q_draws = NULL,        
                                       probs = c(0.025, 0.5, 0.975),
                                       keep_quantiles = TRUE,
                                       seed = 123,
                                       verbose = TRUE,
                                       save_chunks_dir = NULL) {
  
  set.seed(seed)
  
  n_sites   <- nrow(coords.0)
  n_periods <- length(t.cols)
  n_beta    <- dim(X.0)[3]
  n_chunks  <- ceiling(n_sites / chunk_size)
  
  # Get beta samples and orient as matrix: rows = draws, cols = parameters
  if (is.null(model$beta.samples)) stop("model$beta.samples not found in model object.")
  bsm <- model$beta.samples
  
  # Try to get matrix rows = draws, cols = n_beta
  if (is.matrix(bsm)) {
    if (ncol(bsm) == n_beta) {
      beta_mat <- bsm
    } else if (nrow(bsm) == n_beta) {
      beta_mat <- t(bsm)
      warning("Transposing model$beta.samples to get rows = draws.")
    } else {
      # best guess: rows are draws if rows > cols
      if (nrow(bsm) >= ncol(bsm)) {
        beta_mat <- bsm
        warning("Couldn't perfectly match beta.samples dims to X.0. Assuming rows = draws.")
      } else {
        beta_mat <- t(bsm)
        warning("Couldn't perfectly match beta.samples dims to X.0. Assuming columns were draws; transposing.")
      }
    }
  } else if (is.array(bsm) && length(dim(bsm)) == 2) {
    beta_mat <- as.matrix(bsm)
  } else {
    stop("Unsupported format for model$beta.samples.")
  }
  
  n_total_draws <- nrow(beta_mat)
  if (is.null(n_post_draws)) n_post_draws <- min(1000, n_total_draws)
  n_post_draws <- min(n_post_draws, n_total_draws)
  if (is.null(n_q_draws)) n_q_draws <- min(n_post_draws, 200)
  n_q_draws <- min(n_q_draws, n_post_draws)
  
  # Pick draw indices (random subsample of posterior draws)
  draw_idx_all <- sort(sample.int(n_total_draws, size = n_post_draws, replace = FALSE))
  # Which positions in that stream will be used for quantiles
  q_draw_positions <- sort(sample.int(n_post_draws, size = n_q_draws, replace = FALSE))
  
  # Prepare storage
  mean_mat <- matrix(NA_real_, nrow = n_sites, ncol = n_periods)
  sd_mat   <- matrix(NA_real_, nrow = n_sites, ncol = n_periods)
  quantiles_array <- if (keep_quantiles) array(NA_real_, dim = c(n_sites, n_periods, length(probs))) else NULL
  
  # Per-chunk loop
  for (i in seq_len(n_chunks)) {
    idx_start <- (i - 1) * chunk_size + 1
    idx_end   <- min(i * chunk_size, n_sites)
    idx       <- idx_start:idx_end
    nchunk    <- length(idx)
    
    if (verbose) message(sprintf("Chunk %d/%d: sites %d:%d (%d sites)", i, n_chunks, idx_start, idx_end, nchunk))
    
    # Subset X.0 and build design matrix: rows = site*period, cols = n_beta
    Xsub <- X.0[idx, , , drop = FALSE]   # dim: [nchunk, n_periods, n_beta]
    Ncells <- nchunk * n_periods
    
    # Estimate memory for storing quantile draws for this chunk if requested
    if (keep_quantiles) {
      est_bytes <- as.numeric(Ncells) * as.numeric(n_q_draws) * 8
      # if too big (> ~1 GB), reduce n_q_draws for this chunk
      max_bytes <- 1e9
      if (est_bytes > max_bytes) {
        new_n_q <- max(1, floor(max_bytes / (Ncells * 8)))
        if (new_n_q < n_q_draws) {
          warning(sprintf("Chunk %d would need ~%.1f MB to store quantile draws; reducing n_q_draws from %d -> %d for this chunk.",
                          i, est_bytes/1e6, n_q_draws, new_n_q))
          q_draw_positions <- sort(sample.int(n_post_draws, size = new_n_q, replace = FALSE))
        }
      }
    }
    
    # Create X matrix (rows: site-period pairs, column: covariates)
    # Ordering: as.vector(Xsub[,,k]) -> site varies fastest within each period, then next period
    Xmat <- matrix(NA_real_, nrow = Ncells, ncol = n_beta)
    for (k in seq_len(n_beta)) {
      Xmat[, k] <- as.vector(Xsub[,, k])
    }
    
    # Streaming accumulators (Welford)
    mean_vec <- numeric(Ncells)
    M2_vec   <- numeric(Ncells)
    
    # Storage for quantile draws for this chunk (only if requested)
    if (keep_quantiles && length(q_draw_positions) > 0) {
      psi_q_mat <- matrix(NA_real_, nrow = Ncells, ncol = length(q_draw_positions))
      q_counter <- 1L
    } else {
      psi_q_mat <- NULL
      q_counter <- NULL
    }
    
    # Sstream through selected draws
    iter <- 0L
    for (jj in seq_along(draw_idx_all)) {
      sidx <- draw_idx_all[jj]
      beta_s <- beta_mat[sidx, ]
      eta <- as.numeric(Xmat %*% beta_s)      # length Ncells
      psi  <- 1 / (1 + exp(-eta))             # plogis
      
      iter <- iter + 1L
      if (iter == 1L) {
        mean_vec <- psi
        M2_vec   <- numeric(Ncells)
      } else {
        delta <- psi - mean_vec
        mean_vec <- mean_vec + delta / iter
        M2_vec   <- M2_vec + delta * (psi - mean_vec)
      }
      
      # If this draw position was chosen for quantiles, store
      if (!is.null(psi_q_mat) && (jj %in% q_draw_positions)) {
        psi_q_mat[, q_counter] <- psi
        q_counter <- q_counter + 1L
      }
      
      # Occasional garbage collection
      if ((jj %% 200) == 0L) gc(verbose = FALSE)
    } # draws loop
    
    # Finalize chunk summaries
    mean_chunk <- matrix(mean_vec, nrow = nchunk, ncol = n_periods)
    mean_mat[idx, ] <- mean_chunk
    
    if (iter > 1L) {
      sd_vec <- sqrt(M2_vec / (iter - 1L))
      sd_chunk <- matrix(sd_vec, nrow = nchunk, ncol = n_periods)
      sd_mat[idx, ] <- sd_chunk
    } else {
      sd_mat[idx, ] <- NA_real_
    }
    
    # Quantiles (if requested)
    if (!is.null(psi_q_mat)) {
      # apply quantile over rows -> returns matrix (length(probs) x Ncells); transpose to Ncells x length(probs)
      q_mat <- t(apply(psi_q_mat, 1, quantile, probs = probs, na.rm = TRUE))
      # q_mat dims: Ncells x length(probs); reshape into nchunk x n_periods x length(probs)
      q_chunk_array <- array(q_mat, dim = c(nchunk, n_periods, length(probs)))
      quantiles_array[idx, , ] <- q_chunk_array
      rm(psi_q_mat, q_mat, q_chunk_array)
    }
    
    # Optionally save chunk to disk to free memory
    if (!is.null(save_chunks_dir)) {
      dir.create(save_chunks_dir, showWarnings = FALSE, recursive = TRUE)
      saveRDS(list(mean = mean_chunk,
                   sd = matrix(sd_vec, nrow = nchunk, ncol = n_periods),
                   quantiles = if (!is.null(quantiles_array)) quantiles_array[idx, , , drop = FALSE] else NULL),
              file = file.path(save_chunks_dir, sprintf("pred_chunk_%03d.rds", i)))
      # free chunk-level items
      if (verbose) message("Saved chunk ", i, " to disk.")
      if (!is.null(quantiles_array)) quantiles_array[idx, , ] <- NA_real_
      mean_mat[idx, ] <- NA_real_
      sd_mat[idx, ] <- NA_real_
    }
    
    # Free memory and continue
    rm(Xsub, Xmat, mean_vec, M2_vec, mean_chunk); gc(verbose = FALSE)
  } # chunk loop
  
  # Return
  out <- list(mean = mean_mat,
              sd = sd_mat,
              quantiles = quantiles_array,
              probs = probs,
              n_post_draws = n_post_draws,
              n_q_draws = length(q_draw_positions))
  return(out)
}

res <- chunked_predict_from_betas(out, X.0, coords.0, t.cols = 1:n.periods,
                                  chunk_size = 2000,
                                  n_post_draws = 1000,   
                                  n_q_draws = 200,       
                                  keep_quantiles = TRUE,
                                  verbose = TRUE)

# Posterior mean occupancy (sites x periods)
occ_mean <- res$mean

# Posterior sd
occ_sd <- res$sd

# Posterior quantiles (if computed)
occ_lower <- res$quantiles[, , 1]   
occ_median <- res$quantiles[, , 2]
occ_upper <- res$quantiles[, , 3]


## Plotting predicted occupancy -----------------------------------------------

# Formatting data -------------------------------------------------------------

# Convert to long dataframe
df_occ <- occ_mean %>%
  as.data.frame() %>%
  mutate(site = 1:nrow(.),
         x = coords.0[,1],
         y = coords.0[,2]) %>%
  pivot_longer(cols = starts_with("V"), 
               names_to = "period",
               values_to = "mean_occ") %>%
  mutate(period = primary.periods[as.integer(str_remove(period, "V"))])

# Add CIs
df_lower <- as.data.frame(occ_lower) %>%
  mutate(site = 1:nrow(.)) %>%
  pivot_longer(cols = starts_with("V"),
               names_to = "period",
               values_to = "lower") %>%
  mutate(period = primary.periods[as.integer(str_remove(period, "V"))])

df_upper <- as.data.frame(occ_upper) %>%
  mutate(site = 1:nrow(.)) %>%
  pivot_longer(cols = starts_with("V"),
               names_to = "period",
               values_to = "upper") %>%
  mutate(period = primary.periods[as.integer(str_remove(period, "V"))])

df_occ <- df_occ %>%
  left_join(df_lower, by = c("site", "period")) %>%
  left_join(df_upper, by = c("site", "period"))


# Time series with uncertainty ------------------------------------------------

df_occ %>%
  group_by(period) %>%
  summarise(mean = mean(mean_occ, na.rm=TRUE),
            lower = mean(lower, na.rm=TRUE),
            upper = mean(upper, na.rm=TRUE)) %>%
  ggplot(aes(x = period, y = mean)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
  geom_line(size = 1.2, color = "darkblue") +
  labs(y = "Occupancy probability", x = "Period",
       title = "Average occupancy over time") +
  theme_minimal()


# Spatial map for one period --------------------------------------------------

period_sel <- "60"

df_occ_sf <- st_as_sf(df_occ, coords = c("x", "y"), crs = crs(ref), remove = FALSE)
world <- ne_countries(scale = "medium", returnclass = "sf")
world_proj <- st_transform(world, st_crs(df_occ_sf))
world_crop <- st_crop(world_proj, st_bbox(df_occ_sf))
plot_df <- df_occ %>% filter(period == period_sel & !is.na(mean_occ))

(occPeriod <- ggplot() +
    geom_sf(data = world_crop, fill = "gray95", color = "grey30", size = 0.3) +
    geom_tile(data = plot_df, aes(x = x, y = y, fill = mean_occ), alpha = 0.9) +
    scale_fill_viridis_c(option = "C", na.value = NA) +
    coord_sf(xlim = c(min(plot_df$x), max(plot_df$x)),
             ylim = c(min(plot_df$y), max(plot_df$y)), 
             expand = FALSE) +
    labs(x = NULL, y = NULL,
         fill = "Occupancy", 
         title = paste0("Predicted occupancy (Period ", period_sel, ")"), 
         subtitle = bquote(italic(.(target_species)))) +
    theme_minimal() + 
    theme(plot.background = element_rect(fill = "white", color = NA),
          panel.background = element_rect(fill = "white", color = NA)))

file_name <- paste(file_path, "/", target_species, "_occPeriod.jpg", sep="")
ggsave(filename = file_name, plot = occPeriod, width = 6, height = 5, units = "in", bg = "white")


# Difference map (change between two periods) ---------------------------------

min_period <- min(periods$period_counter)
max_period <- max(periods$period_counter)

df_occ_sf <- st_as_sf(df_occ, coords = c("x", "y"), crs = crs(ref), remove = FALSE)
world <- ne_countries(scale = "medium", returnclass = "sf")
world_proj <- st_transform(world, st_crs(df_occ_sf))
world_crop <- st_crop(world_proj, st_bbox(df_occ_sf))

df_diff <- df_occ %>%
  filter(period %in% c(min_period, max_period)) %>%
  select(site, x, y, period, mean_occ) %>%
  pivot_wider(names_from = period, values_from = mean_occ, names_prefix = "period_") %>%
  mutate(diff = .data[[paste0("period_", max_period)]] - 
           .data[[paste0("period_", min_period)]])

(changeOcc <- ggplot() +
    geom_sf(data = world_crop, fill = "gray95", color = "grey30", size = 0.3) +
    geom_tile(data = df_diff, aes(x = x, y = y, fill = diff), alpha = 0.9) +
    scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0) +
    coord_sf(xlim = c(min(df_diff$x), max(df_diff$x)),
             ylim = c(min(df_diff$y), max(df_diff$y)),
             expand = FALSE) +
    labs(x = NULL, y = NULL,
         fill = paste0("Δ occupancy (", max_period, " - ", min_period, ")"),
         title = "Predicted change in occupancy", 
         subtitle = bquote(italic(.(target_species)))) + 
    theme_minimal() +
    theme(plot.background = element_rect(fill = "white", color = NA),
          panel.background = element_rect(fill = "white", color = NA)))

# Save as JPEG
file_name <- paste0(file_path, "/", target_species, "_occChange.jpg")
ggsave(filename = file_name, plot = changeOcc, width = 6, height = 5, units = "in", bg = "white")


# Heatmap (site x period) -----------------------------------------------------

# not terribly informative, do not save 
df_occ %>%
  ggplot(aes(x = period, y = site, fill = mean_occ)) +
  geom_tile() +
  scale_fill_viridis_c(option = "C") +
  labs(x = "Period", y = "Site",
       fill = "Occupancy",
       title = "Occupancy across sites and periods") +
  theme_minimal() +
  theme(axis.text.y = element_blank())


# Animate map over time -------------------------------------------------------

# run only if need to - takes a long time to render 
p <- df_occ %>%
  ggplot(aes(x = x, y = y, fill = mean_occ)) +
  geom_tile() +
  scale_fill_viridis_c(option = "C", limits = c(0,1)) +
  coord_equal() +
  labs(title = "Predicted occupancy: {closest_state}",
       fill = "Occupancy") +
  theme_minimal() +
  transition_states(period, state_length = 1, transition_length = 1)

animate(p, nframes = length(primary.periods)*5, fps = 5)


# Change in occupancy relative to change in covariate -------------------------

# Function to extract occupancy response curves
occ_response <- function(out, dat_ls, covariates, n_points = 100) {
  beta_draws <- as.matrix(out$beta.samples)
  beta_names <- colnames(beta_draws)
  
  cov_means <- sapply(dat_ls$occ.covs, mean, na.rm = TRUE)
  cov_sds   <- sapply(dat_ls$occ.covs, sd, na.rm = TRUE)
  
  results <- list()
  
  for (cov_name in covariates) {
    beta_col <- paste0("scale(", cov_name, ")")
    if (!(beta_col %in% beta_names)) {
      stop(paste("No column in beta.samples matches", beta_col,
                 "\nAvailable:", paste(beta_names, collapse = ", ")))
    }
    
    cov_seq <- seq(min(dat_ls$occ.covs[[cov_name]], na.rm = TRUE),
                   max(dat_ls$occ.covs[[cov_name]], na.rm = TRUE),
                   length.out = n_points)
    cov_seq_scaled <- (cov_seq - cov_means[cov_name]) / cov_sds[cov_name]
    
    # design matrix
    X_pred <- matrix(0, nrow = n_points, ncol = ncol(beta_draws))
    colnames(X_pred) <- beta_names
    
    # intercept
    if ("(Intercept)" %in% beta_names) {
      X_pred[, "(Intercept)"] <- 1
    }
    
    # focal covariate
    X_pred[, beta_col] <- cov_seq_scaled
    
    # predict
    eta <- X_pred %*% t(beta_draws)
    psi <- plogis(eta)
    
    results[[cov_name]] <- data.frame(
      covariate = cov_seq,
      mean = rowMeans(psi),
      low = apply(psi, 1, quantile, 0.025),
      high = apply(psi, 1, quantile, 0.975),
      variable = cov_name
    )
  }
  
  dplyr::bind_rows(results)
}

# Static covariates --- 
cov_labels <- c(road_dist   = "Dist to Roads",
                tri         = "Terrain Ruggedness",
                river_dist  = "Dist to Rivers",
                coeff_var   = "Coefficient of Variation",
                cities_lg   = "Dist to Cities")

covs_to_plot <- names(cov_labels)
plot_df <- occ_response(out, dat_ls, covariates = covs_to_plot)
plot_df$variable <- factor(plot_df$variable,
                           levels = covs_to_plot,
                           labels = cov_labels[covs_to_plot])

(occDeltaStatic <- ggplot(plot_df, aes(x = covariate, y = mean)) +
    geom_ribbon(aes(ymin = low, ymax = high), fill = "grey80") +
    geom_line(size = 1, color = "darkblue") +
    facet_wrap(~ variable, scales = "free_x", ncol = 2) +
    labs(x = "Covariate value", y = "Occupancy probability",
         title = "Change in occupancy across spatial gradients",
         subtitle = bquote(italic(.(as.name(target_species))))) +
    theme_minimal())

# Save as JPEG
file_name <- paste0(file_path, "/", target_species, "_occDeltaStatic.jpg")
ggsave(filename = file_name, plot = occDeltaStatic, width = 6, height = 5, units = "in", bg = "white")

# SVC covariates --- 
cov_labels <- c(crop       = "Proportion Crop",
                gpw        = "Human Population",
                gfc        = "Forest Loss",
                precseas   = "Seasonal Precip",
                wdpa       = "Protected Area Status",
                evi        = "Vegetation", 
                trend      = "Trend (time)")

covs_to_plot <- names(cov_labels)
plot_df <- occ_response(out, dat_ls, covariates = covs_to_plot)
plot_df$variable <- factor(plot_df$variable,
                           levels = covs_to_plot,
                           labels = cov_labels[covs_to_plot])

(occDeltaSVC <- ggplot(plot_df, aes(x = covariate, y = mean)) +
    geom_ribbon(aes(ymin = low, ymax = high), fill = "grey80") +
    geom_line(size = 1, color = "darkblue") +
    facet_wrap(~ variable, scales = "free_x", ncol = 2) +
    labs(x = "Covariate value", y = "Occupancy probability",
         title = "Change in occupancy across SVC gradients",
         subtitle = bquote(italic(.(as.name(target_species))))) +
    theme_minimal())

# Save as JPEG
file_name <- paste0(file_path, "/", target_species, "_occDeltaSVC.jpg")
ggsave(filename = file_name, plot = occDeltaSVC, width = 6, height = 5, units = "in", bg = "white")
