##########################
##### Model Results ######
##########################

## Set workspace --------------------------------------------------------------
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights")
rm(list=ls()); gc()
set.seed(123)

# Load libraries
library(terra)
library(spOccupancy)
library(coda)
library(stringr)
library(ggplot2)
library(rasterVis)


## Load data ------------------------------------------------------------------
filenames <- list.files("Model outputs", full.names = TRUE) 
species <- "Panthera pardus"
file_path <- filenames[grep(species, filenames)]
file_name_only <- basename(file_path)
filename <- paste0(file_path, "/", file_name_only, "_svcTPGOcc.RData")
load(filename)


## Results --------------------------------------------------------------------

## Basic summary
summary(out)

## Parameter plots: Occurrence 
occ.samps <- out$beta.samples 
occ_quantiles <- as.data.frame(matrix(NA, ncol(occ.samps), 6)) 
colnames(occ_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
occ_quantiles$covariate <- colnames(occ.samps)
occ_quantiles$covariate <- c("Intercept", "Crop", "GPW", "Precip", "WDPA", "EVI", "Road Dist", "TRI", "River Dist", "CV", "City Dist", "Trend") #update as appropriate 
desired_order <- c("TRI", "Road Dist", "River Dist", "City Dist", "CV",
                   "Crop", "GPW", "Precip", "WDPA", "EVI", "Trend", "Intercept")
occ_quantiles$covariate <- factor(occ_quantiles$covariate, levels = desired_order)
occ_quantiles$mean <- colMeans(occ.samps)
occ_quantiles[,3:6] <- t(apply(occ.samps, 2, quantile, probs = c(0.025, 0.25, 0.75, 0.975)))

(occParams <- ggplot(occ_quantiles, aes(x = covariate, y = mean)) +
  geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
  geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                linewidth = 1.5, show.legend = FALSE) +
  geom_point() +
  theme_bw() +
  geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
  xlab('Covariates (scaled)') +
  ylab('Posterior Distribution') +
  ggtitle('Occurrence coefficients', 'Multi-season, single-species model') + 
  coord_flip())

file_name <- paste(file_path, "/", target_species, "_occurrenceParams.jpg", sep="")
ggsave(filename = file_name, plot = occParams, width = 6, height = 5, units = "in")

## Parameter plots: Detection 
det.samps <- out$alpha.samples
det_quantiles <- as.data.frame(matrix(NA, ncol(det.samps), 6))
colnames(det_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
det_quantiles$covariate <- colnames(det.samps)
det_quantiles$covariate <- c("Intercept", "Effort", "Julian Day", "Julian Day Sq", "N. Depl") #update as appropriate
desired_order <- c("Effort", "N. Depl", "Julian Day", "Julian Day Sq", "Intercept")
det_quantiles$covariate <- factor(det_quantiles$covariate, levels = desired_order)
det_quantiles$mean <- colMeans(det.samps)
det_quantiles[,3:6] <- t(apply(det.samps ,2,quantile,probs=c(0.025, 0.25, 0.75, 0.975)))

(detParams <- ggplot(det_quantiles, aes(x = covariate, y = mean)) +
  geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
  geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                linewidth = 1.5, show.legend = FALSE) +
  geom_point() +
  theme_bw() +
  geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
  xlab('Covariates (scaled)') +
  ylab('Posterior Distribution') +
  ggtitle('Detection coefficients', 'Multi-season, single-species model') + 
  coord_flip())

file_name <- paste(file_path, "/", target_species, "_detectionParams.jpg", sep="")
ggsave(filename = file_name, plot = detParams, width = 6, height = 3, units = "in")


# -> Interpretations:
#      - Coefficients are estimated for the logit(ψ) = βX model and thus must be 
#        interpreted on the logit scale
#      - Positive beta coefficents imply that an increase in the value of that 
#        covariate results in an increase in the probability of occurrence, when
#        all other covariate values are held constant.
#      - Negative beta coefficents imply that an increase in the value of that 
#        covariate results in a decrease in the probability of occurrence, when 
#        all other covariate values are held constant.

## Predictions ----------------------------------------------------------------

# Predict occupancy across all sites in the original data list 

svc.out <- out #this contain trends 
static.out <- out #this contains only spatially varying 

I DO NOT THINK THIS HANDLES SVC VARYING COVARIATES --- FIX!!! vignette not helpful - does not consider replicates? adapt for primary periods and replicates

# Number of sites 
(n.sites <- length(unique(covs$cell_ID)))

# Number of primary periods  
(n.period <- length(seq(min(covs$period_counter), max(covs$period_counter), by = 1)))

# Number of replicates 
n.rep <- 13 

# Number of occupancy regression parameters -- CHANGE THE OUT 
(n.beta <- ncol(svc.out$beta.samples))

# Create and fill an empty array with the proper dimensions --- NEED TO ADD REPLICATES? try without first? 
X.0 <- array(NA, dim = c(n.sites, n.period, n.beta))

# Intercept
X.0[, , 1] <- 1

QUESTION -- if variables are already standardized in dat_ls, no need to repeat here -- examine input data

# Primary period (standardized by values used to fit the model)
period.pred <- (as.numeric(dat_ls$occ.covs$trend))
X.0[, , 2] <- period.pred

# Crops (standardized by values used to fit the model) --- PULL THESE FROM DAT_LS? 
crop.pred <- (as.numeric(dat_ls$occ.covs$crop) - mean(as.numeric(fit.data$occ.covs$crop)) / sd(as.numeric(fit.data$occ.covs$crop)))
X.0[, , 3] <- crop.pred

# Cities 
cities.pred <- (as.numeric(dat_ls$occ.covs$cities_lg) - mean(as.numeric(fit.data$occ.covs$cities_lg)) / sd(as.numeric(fit.data$occ.covs$cities_lg)))
X.0[, , 4] <- cities.pred

# Give names to X.0 just to make things clear
dimnames(X.0)[[3]] <- c('(Intercept)', 'periods', 'crop', 'cities')

# Prediction coordinates
coords.0 <- full.data$coords
# Predict across all years and sites in the original data set
out.pred.occ <- predict(svc.out, X.0, coords.0, t.cols = 1:n.years, type = 'occupancy')
str(out.pred.occ)

# Can then manipulate the objects in out.pred.occ as desired
# e.g., calculate mean occupancy probability for each site/period
psi.means <- apply(out.pred.occ$psi.0.samples, c(2, 3), mean)

WHY ARE ALL psi.0.samples NA? 
  sum(is.na(out.pred.occ$psi.0.samples))/length(out.pred.occ$psi.0.samples)
something scaled covariates issue?? 
  
  #prediction for occurance
  out.pred_occ <- predict(modelout.sp_1, X.0_occ, predict_coords,
                          t.cols = c(1, 4,7), #set 1 - monsoon
                          n.omp.threads = 8, type = 'occupancy')
summary(out.pred_occ)

mean.psi <- apply(out.pred_occ$psi.0.samples, 2, mean)
sd.psi <- apply(out.pred_occ$psi.0.samples, 2, sd)




# Number of prediction sites.
J.pred <- nrow(hbefElev)
# Number of prediction years.
n.years.pred <- 2
# Number of predictors (including intercept)
p.occ <- ncol(out.ar1$beta.samples)
# Get covariates and standardize them using values used to fit the model
elev.pred <- (hbefElev$val - mean(revi.data$occ.covs$elev)) / sd(revi.data$occ.covs$elev)
year.pred <- matrix(rep((c(2010, 2018) - mean(revi.data$occ.covs$years)) / 
                          sd(revi.data$occ.covs$years), 
                        length(elev.pred)), J.pred, n.years.pred, byrow = TRUE)
# Create three-dimensional array
X.0 <- array(1, dim = c(J.pred, n.years.pred, p.occ))
# Fill in the array
# Years
X.0[, , 2] <- year.pred
# Elevation
X.0[, , 3] <- elev.pred
# Elevation^2
X.0[, , 4] <- elev.pred^2
# Check out the structure
str(X.0)
# Indicate which primary time periods (years) we are predicting for
t.cols <- c(1, 9)
# Approx. run time: < 30 sec
out.pred <- predict(out.ar1, X.0, t.cols = t.cols, ignore.RE = TRUE, type = 'occupancy')
# Check out the structure
str(out.pred)
#we plot the mean of REVI occurrence probability in 2009 and 2018 across the forest.
plot.dat <- data.frame(x = hbefElev$Easting, y = hbefElev$Northing, 
                       mean.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, mean), 
                       mean.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, mean), 
                       sd.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, sd), 
                       sd.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, sd), 
                       stringsAsFactors = FALSE)

# Make a species distribution map showing the point estimates, or predictions (posterior means)
dat.stars <- st_as_stars(plot.dat, dims = c('x', 'y'))

# 2009
ggplot() + geom_stars(data = dat.stars, aes(x = x, y = y, fill = mean.2009.psi)) +
  scale_fill_viridis_c(na.value = 'transparent') +
  labs(x = 'Easting', y = 'Northing', fill = '', 
       title = 'Mean REVI occurrence probability 2009') +
  theme_bw()  





# We now use our fitted model to predict occurrence across all cells in our study area. We use the predict function within the spOcc package, which intakes a design matrix of the covariate values to predict over. Note that the design matrix must match the order of covariates used to fit the model. The covariate values that we predict over must be standardized (scaled) in the same way that the variables were standardized to fit the model. This means they must be scaled against all covariate values.

TO DO: Here somehow have to get bb on area surveyed, extract covariates for this area at 10x10 km2 scale. That means need to ensure have global covarage on covs, not just cropped coverage

# Scale covariates 
fc.0 <- scale(occ_covs_all$Forest_PercentCover)
Cliffs.0 <- scale(occ_covs_all$CliffsCanyons_PercentCover)
Precip.0 <- scale(occ_covs_all$MeanAnnualPrecipitation_mm)

# Create prediction design matrix (1 = intercept)
X.0 <- cbind(1, fc.0, Cliffs.0, Precip.0)

out.pred <- predict(out, X.0)
psi.0.samples <- out.pred$psi.0.samples

# MSP: assuming it is here that I can combine across years and plot?? 


# Assuming you have a fitted svcTPGOcc model object named 'svc_model'
# and a data frame 'new_data' with covariates for prediction locations and years.

# Predict occupancy probability at new locations and/or future years
predicted_occupancy <- predict(svc_model, X.0 = new_data)

# 'predicted_occupancy' will contain posterior predictive samples for occupancy
# at the specified locations and years, allowing you to assess uncertainty.


# ## Predict -------

# ?predict.stPGOcc()
# REVISIT: https://doserlab.com/files/spoccupancy-web/articles/modelfitting#prediction 






# We create our final predictive maps from the full posterior predictive distributions of ψ across the 4500 cells.

# Occurrence probability means:
psi.0.mean <- apply(psi.0.samples, 2, mean)
# -> each column of psi.0.samples is an MCMC sample of the psi for one site
# -> these are the means ordered in that vector based on their cell

length(psi.0.mean) #this is mean values across all the cells, so we need a map to interpret it

# Find 95% credible intervals and widths of 95% credible interval for occurrence probability estimates:
quantiles.ordered.samples <- as.data.frame(
  t(apply(psi.0.samples ,2,quantile,probs=c(0.025,0.975))))
quantiles.ordered.samples$width <- quantiles.ordered.samples[,2] -
  quantiles.ordered.samples[,1]

# Predictive plots require the shapefile for the 10x10 grids that can be linked to the unique cell IDs. 

# Create a dataframe for plotting:Plot names in the covariates and in the prediction outputs line up because that is the order it was read into the prediction formula

predicted.df <- data.frame(Cell= occ_covs_all$Cell,
                           psi.mean = psi.0.mean,
                           psi.width = quantiles.ordered.samples$width)

# Join the predicted results to the spatial grid, using the plot name
plottable <- left_join(select(grid_shp,Cell, geometry),
                       predicted.df,
                       by = 'Cell')
# There are some NA grid cells that didn't have covariate values and don't have predictions; remove them: 
plottable <- na.omit(plottable)

ggplot(data = plottable) +
  geom_sf(aes(fill = psi.mean), lwd = 0.05) +
  theme_bw() +
  viridis::scale_fill_viridis(limits = c(0, 1)) +
  ggtitle('LANO posterior mean predicted occurrence',
          'Single-season, single-species model')

ggplot(plottable) +
  geom_sf(aes(fill = psi.width), lwd = 0.05) +
  theme_bw() +
  viridis::scale_fill_viridis(option = 'plasma', limits = c(0, 1)) +
  ggtitle('LANO predicted occurrence 95% interval width',
          'Single-season, single-species model')



# Below we predict across the 400 “new” locations and plot them in comparison to the true values we used to simulate the data.

# Predict occupancy at the 400 new sites
out.pred <- predict(out.svc.trend, X.pred, coords.pred, t.cols = 1:n.time.max)

# get SVC values at the prediction locations
svc.pred.samples <- getSVCSamples(out.svc.trend, pred.object = out.pred)

# Get mean values of the SVC for the covariate
svc.cov.pred.mean <- apply(svc.pred.samples$occ.cov.1, 2, mean)

# Plot
plot(coords.pred, type = "n", xlab = "", ylab = "", asp = TRUE, 
     main = "Estimated values", bty = 'n')
points(coords.pred, pch=15, cex = 2.1, 
       col = rgb(0,0,0,(svc.cov.pred.mean-min(svc.cov.pred.mean))/diff(range(svc.cov.pred.mean))))

## adapt 
# First standardize elevation using mean and sd from fitted model
elev.pred <- (hbefElev$val - mean(btbwHBEF$occ.covs[, 1])) / sd(btbwHBEF$occ.covs[, 1])
coords.0 <- as.matrix(hbefElev[, c('Easting', 'Northing')])
X.0 <- cbind(1, elev.pred, elev.pred^2)
out.pred <- predict(out, X.0, coords.0, verbose = FALSE)

# Plot spatially varying trend across study region  
**FIX THIS**
  
  y <- yarray            #detection-nondetection data
X <- dat$X             #occurrence design matrix for fixed effects
X.p <- dat$X.p         #detection design matrix for fixed effets  
psi <- dat$psi         #occurrence values
coords <- coords       #spatial coordinates
w <- dat$w             #spatially varying intercept and covariate effects
cov.effect <- beta[2] + w[, 2]
plot.dat <- data.frame(x = coords[, 1], 
                       y = coords[, 2], 
                       cov.effect = cov.effect)

ggplot(plot.dat, aes(x = x, y = y, fill = cov.effect)) + 
  geom_raster() + 
  scale_fill_gradient2(midpoint = 0, low = '#B2182B', mid = 'white', 
                       high = '#2166AC', na.value = NA) + 
  theme_bw() 
# (decrease in occurrence = red, increase in occurrence = blue)





## Occurrence data across study area ------------------------------------------

# We may be interested in average occurrence across the whole study area, which can be computed as a derived quantity of the cell-level occurrences. We include naive average occurrence across surveyed cells as a solid line.

psi <- as.data.frame(out$psi.samples) # samples of latent psi across all sites
#this is psi sampled across all 169 sites
avg_psi <- rowMeans(psi) #take averages across all columns (sites)
avg_psi_naive <- mean(as.numeric(as.character(naive$Naive_occupancy))) FIGURE THIS OUT 
hist(avg_psi, breaks = 20, freq=F, main = "", xlab = "Mean occurrence across all cells")
abline(v = avg_psi_naive, lwd = 2) FIGURE THIS OUT 




## add in the following 

## Estimates of SVCs 

# To extract the estimates of the spatially varying coefficients at each of the spatial locations in the data set used to fit the model, we need to combine the non-spatial component of the coefficient (contained in out.svc$beta.samples) and the spatial component of the coefficient (contained in out.svc$w.samples). Recall that in an SVC occupancy model, the total effect of a covariate at any given location is the sum of the non-spatial effect and the adjustment of the effect at that specific location. We provide the function getSVCSamples() to extract the SVCs at each location.

# The resulting object, here called svc.samples, is a list with each component corresponding to a matrix of the MCMC samples of each spatially varying coefficient estimated in the model, with rows corresponding to MCMC sample and column corresponding to site.

svc.samples <- getSVCSamples(out) 
str(svc.samples)

# Intercept 
svc.samples <- getSVCSamples(out.svc.trend)
int.quants <- apply(svc.samples[["(Intercept)"]], 2, quantile, 
                    probs = c(0.025, 0.5, 0.975))
svc.true.fit <- beta + w.fit
plot(svc.true.fit[, 1], int.quants[2, ], pch = 19, 
     ylim = c(min(int.quants[1, ]), max(int.quants[3, ])),
     xlab = "True", ylab = "Fit", main = 'Intercept')
abline(0, 1)
arrows(svc.true.fit[, 1], int.quants[2, ], svc.true.fit[, 1], col = 'gray', 
       int.quants[1, ], length = 0.02, angle = 90)
arrows(svc.true.fit[, 1], int.quants[1, ], svc.true.fit[, 1], col = 'gray', 
       int.quants[3, ], length = 0.02, angle = 90)
points(svc.true.fit[, 1], int.quants[2, ], pch = 19)

# Trend -------------------------------------------------------------------
trend.quants <- apply(svc.samples[["trend"]], 2, quantile, 
                      probs = c(0.025, 0.5, 0.975))
plot(svc.true.fit[, 2], trend.quants[2, ], pch = 19, 
     ylim = c(min(trend.quants[1, ]), max(trend.quants[3, ])),
     xlab = "True", ylab = "Fit", main = 'Spatially-Varying Trends')
abline(0, 1)
arrows(svc.true.fit[, 2], trend.quants[2, ], svc.true.fit[, 2], col = 'gray', 
       trend.quants[1, ], length = 0.02, angle = 90)
arrows(svc.true.fit[, 2], trend.quants[1, ], svc.true.fit[, 2], col = 'gray', 
       trend.quants[3, ], length = 0.02, angle = 90)
points(svc.true.fit[, 2], trend.quants[2, ], pch = 19)


#https://code.usgs.gov/usgs/norock/irvine_k/vignette-bayesian-site-occupancy-model-bat-acoustic-data/-/blob/main/LANO-OR-WA-vignette.pdf?ref_type=heads
#Plotting covariates
ggplot(data = plottable_covs) +
  geom_sf(aes(fill = Forest_PercentCover), lwd = 0.05 ) +
  theme_bw() +
  viridis::scale_fill_viridis(limits = c(0, 1))




# Load full reference grid ---------------------------------------------------------------
grid_full <- rast("/gpfs/gibbs/pi/jetz/wildlife_insights/RWT/data/data_for_annotation/Global_1km_CEA_reference_raster_with_cellID.tif")

# Load range map ---------------------------------------------------------------
file_rangemap <- list.files("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/", full.names = TRUE) %>% 
  str_subset(pattern = species_full)
#rangemap <- rast("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/Suncus_etruscus.tif")
rangemap <- rast(file_rangemap)
rangemap_bf <- buffer(rangemap, width = 100000) #500 km
rangemap_bf <- as.numeric(rangemap_bf) # from true/false to 1/0
rangemap_bf <- ifel(rangemap_bf == 0, NA, 1)



# Subset grid based on range map -----------------------------------------------
grid_sub <- terra::crop(grid_full, rangemap_bf) # to make extent match
grid_sub <- terra::mask(grid_sub, rangemap_bf) # to mask 

# plot(grid_sub, y = 2)
# plot(rangemap_bf)
# plot(rangemap, add = TRUE, col = "red")
# plot(rangemap_bf, add = TRUE, col = "blue")
# plot(world,  col=NULL, "l", add = TRUE)
# points(coords, col = "blue")


# Remove no-land ---------------------------------------------------------------
land <- rast("/gpfs/gibbs/pi/jetz/data/regions_datasets/MOL_land_layer/v2/MOL_Land_Layer_Countries_Fixed_1km.tiff") %>% 
  terra::project(crs(grid_sub))

land_sub <- terra::crop(land, grid_sub) # to make extent match
land_sub <- ifel(land_sub == 0, NA, 1)
land_sub_rs <- resample(land_sub, grid_sub) # resample to align
grid_land <- terra::mask(grid_sub, land_sub_rs) # to remove no-land 

# Extract covariates -----------------------------------------------------------
