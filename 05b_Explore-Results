##########################
##### Model Results ######
##########################

## Set workspace --------------------------------------------------------------
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights")
rm(list=ls()); gc()
set.seed(123)

# Load libraries
library(tidyterra)
library(terra)
library(spOccupancy)
library(coda)
library(stringr)
library(ggplot2)
library(rasterVis)
library(rnaturalearth)
library(sf)


## Load data ------------------------------------------------------------------

filenames <- list.files("Model outputs", full.names = TRUE) 
species <- "Acinonyx jubatus"

# Model outputs 
file_path <- filenames[grep(species, filenames)]
file_name_only <- basename(file_path)
filename <- paste0(file_path, "/", file_name_only, "_svcTPGOcc.RData")
load(filename)

# MOL range maps 
species_file <- gsub(" ", "_", species)
mmd_map_path <- paste("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/", species_file, ".tif", sep="")
mmd_map <- rast(mmd_map_path)


## Results --------------------------------------------------------------------

## Basic summary
summary(out)

## Parameter plots: Occurrence 
occ.samps <- out$beta.samples 
occ_quantiles <- as.data.frame(matrix(NA, ncol(occ.samps), 6)) 
colnames(occ_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
occ_quantiles$covariate <- colnames(occ.samps)
occ_quantiles$covariate <- c("Intercept", "Crop", "GPW", "Precip", "WDPA", "EVI", "GFC", "Road Dist", "TRI", "River Dist", "CV", "City Dist", "Trend") #update as appropriate 
desired_order <- c("TRI", "Road Dist", "River Dist", "City Dist", "CV",
                   "Crop", "GPW", "Precip", "WDPA", "EVI", "GFC", "Trend", "Intercept")
occ_quantiles$covariate <- factor(occ_quantiles$covariate, levels = desired_order)
occ_quantiles$mean <- colMeans(occ.samps)
occ_quantiles[,3:6] <- t(apply(occ.samps, 2, quantile, probs = c(0.025, 0.25, 0.75, 0.975)))

(occParams <- ggplot(occ_quantiles, aes(x = covariate, y = mean)) +
    geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
    geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                  linewidth = 1.5, show.legend = FALSE) +
    geom_point() +
    theme_bw() +
    geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
    xlab('Covariates (scaled)') +
    ylab('Posterior Distribution') +
    ggtitle('Occurrence coefficients', 'Multi-season, single-species model') + 
    coord_flip())

file_name <- paste(file_path, "/", target_species, "_occurrenceParams.jpg", sep="")
ggsave(filename = file_name, plot = occParams, width = 6, height = 5, units = "in")

## Parameter plots: Detection 
det.samps <- out$alpha.samples
det_quantiles <- as.data.frame(matrix(NA, ncol(det.samps), 6))
colnames(det_quantiles) <- c("covariate", "mean", "q2.5", "q25", "q75", "q97.5")
det_quantiles$covariate <- colnames(det.samps)
det_quantiles$covariate <- c("Intercept", "Effort", "Julian Day", "Julian Day Sq", "N. Depl") #update as appropriate
desired_order <- c("Effort", "N. Depl", "Julian Day", "Julian Day Sq", "Intercept")
det_quantiles$covariate <- factor(det_quantiles$covariate, levels = desired_order)
det_quantiles$mean <- colMeans(det.samps)
det_quantiles[,3:6] <- t(apply(det.samps ,2,quantile,probs=c(0.025, 0.25, 0.75, 0.975)))

(detParams <- ggplot(det_quantiles, aes(x = covariate, y = mean)) +
    geom_errorbar(aes(ymin = q2.5, ymax = q97.5), width = 0, linewidth = 0.6) +
    geom_errorbar(aes(ymin = q25, ymax = q75, color = covariate), width = 0,
                  linewidth = 1.5, show.legend = FALSE) +
    geom_point() +
    theme_bw() +
    geom_hline(yintercept = 0, lty = 2, linewidth = 0.3) +
    xlab('Covariates (scaled)') +
    ylab('Posterior Distribution') +
    ggtitle('Detection coefficients', 'Multi-season, single-species model') + 
    coord_flip())

file_name <- paste(file_path, "/", target_species, "_detectionParams.jpg", sep="")
ggsave(filename = file_name, plot = detParams, width = 6, height = 3, units = "in")


# -> Interpretations:
#      - Coefficients are estimated for the logit(ψ) = βX model and thus must be 
#        interpreted on the logit scale
#      - Positive beta coefficents imply that an increase in the value of that 
#        covariate results in an increase in the probability of occurrence, when
#        all other covariate values are held constant.
#      - Negative beta coefficents imply that an increase in the value of that 
#        covariate results in a decrease in the probability of occurrence, when 
#        all other covariate values are held constant.


## Predictions ----------------------------------------------------------------

## Predict 
# from: https://doserlab.com/files/spoccupancy-web/articles/modelfitting#prediction 
# hbefElev --- make this is a bounding box of sites (later, update to MOL range map)

# load and format reference ---------------------------------------------------
ref <- rast("10x10 km spatial layers/raster_100km2_with_cellID.tif")
world <- ne_countries(scale = "medium", returnclass = "sf")

# get bounding box for species detection sites
plot_coords <- as.data.frame(coords) 
crs <- crs(ref)
plot_coords_sf <- st_as_sf(plot_coords, coords = c("x", "y"), crs = crs)  
bbox_sf <- st_as_sfc(st_bbox(plot_coords_sf))

# get bounding box for expert range maps 
bbox_mmd <- ext(mmd_map)
bbox_sf_mmd <- st_as_sfc(st_bbox(mmd_map))

# Plot detection sites --------------------------------------------------------
world <- ne_countries(scale = "medium", returnclass = "sf")
world <- st_transform(world, crs = crs)

ggplot() + 
  geom_sf(data = world, fill = "gray90", color = "gray60", linewidth = 0.3) +
  geom_spatraster(data = mmd_map) + 
  geom_sf(data = plot_coords_sf, color = "violet", size = 2) +
  scale_fill_viridis_c(na.value = NA) +
  theme_minimal() + theme(legend.position = "none") + 
  labs(title = "Species Detection Sites")

# Plot zoomed to bbox ---------------------------------------------------------
world_cropped_mmd <- st_crop(world, bbox_mmd)
(speciesDet <- ggplot() +
    geom_sf(data = world_cropped_mmd, fill = "gray90", color = "gray60") +
    geom_spatraster(data = mmd_map) + 
    geom_sf(data = plot_coords_sf, color = "violet", size = 2) +
    #geom_sf(data = bbox_sf_mmd, fill = NA, color = "red", size = 1) +
    scale_fill_viridis_c(na.value = NA) +
    theme_minimal() + theme(legend.position = "none") + 
    labs(title = "Species Detection Sites [Zoomed]"))

file_name <- paste(file_path, "/", target_species, "_speciesDetections.jpg", sep="")
ggsave(filename = file_name, plot = speciesDet, width = 6, height = 5, units = "in")


# Crop to get cell_IDs within MMD ---------------------------------------------
mmd_repro <- project(mmd_map, ref)
masked_ref <- mask(ref, mmd_repro)
plot(masked_ref)
mmd_cellIDs <- unique(masked_ref$cell_ID)


# Format static covs ----------------------------------------------------------
static_covs <- read.csv("Covariates for modelling/site_level_covariates_full.csv") %>% 
  mutate(across(
    .cols = c(road_dist, tri, river_dist, coeff_var, cities_lg),
    .fns = ~ (. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE),
    .names = "{.col}_scaled"
  )) %>% 
  dplyr::select(-c(road_dist, tri, river_dist, coeff_var, cities_lg)) %>% 
  filter(cell_ID %in% mmd_cellIDs$cell_ID)

# these are now scaled: 
road_dist.0 <- static_covs$road_dist
tri.0 <- static_covs$tri
river_dist.0 <- static_covs$river_dist
coeff_var.0 <- static_covs$coeff_var
cities_lg.0 <- static_covs$cities_lg


# Format dynamic covariates ---------------------------------------------------
primary.periods <- seq(min(covs$period_counter), max(covs$period_counter), by = 1)

# extraction function
cov_subset <- function(cov_dataframe_name, primary.periods, cell_IDs){
  covariate <- read.csv(cov_dataframe_name) %>% 
    dplyr::select(-any_of("X")) %>% 
    filter(cell_ID %in% cell_IDs) %>% 
    arrange(cell_ID)
  cols <- grep(
    paste0("^X(", paste(primary.periods, collapse = "|"), ")$"),
    names(covariate),
    value = TRUE
  )
  cols <- cols[order(as.numeric(sub("X", "", cols)))]
  covariate <- covariate %>% 
    select(all_of(cols)) %>% 
    as.matrix() 
  return(covariate)
}

# processed values 
crop.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_crop_full.csv", primary.periods, mmd_cellIDs$cell_ID) 
evi.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_EVI_full.csv", primary.periods, mmd_cellIDs$cell_ID)
gpw.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_GPW_full.csv", primary.periods, mmd_cellIDs$cell_ID)
precseas.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_precseas_full.csv", primary.periods, mmd_cellIDs$cell_ID)
wdpa.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_WDPA_full.csv", primary.periods, mmd_cellIDs$cell_ID) 
gfc.0 <- cov_subset("Covariates for modelling/primary_occ_covariates_GFC_full.csv", primary.periods, mmd_cellIDs$cell_ID)
trend.0 <- matrix(rep(primary.periods, each = length(mmd_cellIDs$cell_ID)),
                  nrow = length(mmd_cellIDs$cell_ID),
                  ncol = length(primary.periods),
                  byrow = FALSE)
colnames(trend.0) <- as.character(primary.periods)


## Create prediction design matrix (1 = intercept) ----------------------------
X.0 <- cbind(1, 
             crop.0, 
             gpw.0, 
             precseas.0, 
             wdpa.0, 
             evi.0, 
             gfc.0, 
             road_dist.0, tri.0, river_dist.0, coeff_var.0, cities_lg.0, 
             trend.0)

SCALE THESE ^^ 
  occ.formula = ~ scale(crop) + scale(gpw) + scale(precseas) + scale(wdpa) + scale(evi) + scale(gfc) + road_dist + tri + river_dist + coeff_var + cities_lg + scale(trend)


## Predict occupancy for all years --------------------------------------------
t.cols <- primary.periods
coords.0 <- static_covs[,c("x","y")] %>% distinct()  # BUT NEED TO MAKE LIKE AN ARRAY 
out.pred <- predict(out, X.0, coords.0, t.cols = t.cols, ignore.RE = TRUE, type = 'occupancy')


# ------------------------
# 3. Collapse to average occupancy per year
# ------------------------

# out.pred$psi.samples has dimension: [iterations × sites × years]
psi.samples <- out.pred$psi.samples

# Average across sites for each iteration and year
psi.mean.by.year <- apply(psi.samples, c(1, 3), mean)  # [iterations × years]

# Summarize posterior mean & CI per year
occ.summary <- data.frame(
  year = years,
  mean = apply(psi.mean.by.year, 2, mean),
  lower = apply(psi.mean.by.year, 2, quantile, 0.025),
  upper = apply(psi.mean.by.year, 2, quantile, 0.975)
)

# ------------------------
# 4. Plot occupancy vs year
# ------------------------

ggplot(occ.summary, aes(x = year, y = mean)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "gray80", alpha = 0.6) +
  geom_line(color = "blue", size = 1) +
  labs(x = "Year", y = "Occupancy probability (ψ)", 
       title = "Predicted occupancy across sites") +
  theme_minimal()






# Number of prediction sites
J.pred <- nrow(static_covs)

# Number of prediction years 
n.years.pred <- 25 

# Number of occupancy predictors (including intercept) 
p.occ <- ncol(out$beta.samples)

# Get covariates and standardize them using values used to fit the model
tri.pred <- (static_covs$tri - mean(dat_ls$occ.covs$tri)) / sd(dat_ls$occ.covs$tri) #shouldn't need?
year_1999_scaled <- (1999 - mean(dat_ls$occ.covs$years)) / sd(dat_ls$occ.covs$years)
year.pred <- matrix(year_1999_scaled, nrow = J.pred, ncol = 1)

# Create three-dimensional array
X.0 <- array(1, dim = c(J.pred, n.years.pred, p.occ))

# Fill in the array
X.0[, , 2] <- year.pred #years
X.0[, , 3] <- tri.pred #elevation
str(X.0)

# Indicate which primary time periods (years) we are predicting for
t.cols <- c(1, 9)

# Predict 
out.pred <- predict(out, X.0, t.cols = t.cols, ignore.RE = TRUE, type = 'occupancy')
str(out.pred)


#we plot the mean of REVI occurrence probability in 2009 and 2018 across the forest.
plot.dat <- data.frame(x = hbefElev$Easting, y = hbefElev$Northing, 
                       mean.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, mean), 
                       mean.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, mean), 
                       sd.2009.psi = apply(out.pred$psi.0.samples[, , 1], 2, sd), 
                       sd.2018.psi = apply(out.pred$psi.0.samples[, , 2], 2, sd), 
                       stringsAsFactors = FALSE)

# Make a species distribution map showing the point estimates, or predictions (posterior means)
dat.stars <- st_as_stars(plot.dat, dims = c('x', 'y'))

# 2009
ggplot() + geom_stars(data = dat.stars, aes(x = x, y = y, fill = mean.2009.psi)) +
  scale_fill_viridis_c(na.value = 'transparent') +
  labs(x = 'Easting', y = 'Northing', fill = '', 
       title = 'Mean REVI occurrence probability 2009') +
  theme_bw()  




# We now use our fitted model to predict occurrence across all cells in our study area. We use the predict function within the spOcc package, which intakes a design matrix of the covariate values to predict over. Note that the design matrix must match the order of covariates used to fit the model. The covariate values that we predict over must be standardized (scaled) in the same way that the variables were standardized to fit the model. This means they must be scaled against all covariate values.

TO DO: Here somehow have to get bb on area surveyed, extract covariates for this area at 10x10 km2 scale. That means need to ensure have global covarage on covs, not just cropped coverage

# Scale covariates 
fc.0 <- scale(occ_covs_all$Forest_PercentCover)
Cliffs.0 <- scale(occ_covs_all$CliffsCanyons_PercentCover)
Precip.0 <- scale(occ_covs_all$MeanAnnualPrecipitation_mm)

# Create prediction design matrix (1 = intercept)
X.0 <- cbind(1, fc.0, Cliffs.0, Precip.0)

out.pred <- predict(out, X.0)
psi.0.samples <- out.pred$psi.0.samples

# MSP: assuming it is here that I can combine across years and plot?? 


# Assuming you have a fitted svcTPGOcc model object named 'svc_model'
# and a data frame 'new_data' with covariates for prediction locations and years.

# Predict occupancy probability at new locations and/or future years
predicted_occupancy <- predict(svc_model, X.0 = new_data)

# 'predicted_occupancy' will contain posterior predictive samples for occupancy
# at the specified locations and years, allowing you to assess uncertainty.


# ## Predict -------

# load and format reference ---------------------------------------------------
ref <- rast("10x10 km spatial layers/raster_100km2_with_cellID.tif")
world <- ne_countries(scale = "medium", returnclass = "sf")

# get bounding box for species detection sites
plot_coords <- as.data.frame(coords) 
crs <- crs(ref)
plot_coords_sf <- st_as_sf(plot_coords, coords = c("x", "y"), crs = crs)  
bbox_sf <- st_as_sfc(st_bbox(plot_coords_sf))

# Plot detection sites --------------------------------------------------------
world <- ne_countries(scale = "medium", returnclass = "sf")
world <- st_transform(world, crs = crs)

ggplot() +
  geom_sf(data = world, fill = "gray90", color = "gray60") +
  geom_sf(data = plot_coords_sf, color = "violet", size = 2) +
  theme_minimal() +
  labs(title = "Species Detection Sites")

# Plot zoomed to bbox ---------------------------------------------------------
world_cropped <- st_crop(world, bbox_sf) 

ggplot() +
  geom_sf(data = world_cropped, fill = "gray90", color = "gray60") +
  geom_sf(data = plot_coords_sf, color = "violet", size = 2) +
  geom_sf(data = bbox_sf, fill = NA, color = "red", size = 1) +
  theme_minimal() +
  labs(title = "Species Detection Sites [Zoomed]")

# Crop raster to bbox to get cell_IDs within bounding box ---------------------
r_cropped <- crop(ref, bbox_sf)
r_df <- as.data.frame(r_cropped, xy = TRUE)

# Format static covs ----------------------------------------------------------
static_covs <- read.csv("Covariates for modelling/site_level_covariates_full.csv") %>% 
  filter(cell_ID %in% r_df$cell_ID)






# We create our final predictive maps from the full posterior predictive distributions of ψ across the 4500 cells.

# Occurrence probability means:
psi.0.mean <- apply(psi.0.samples, 2, mean)
# -> each column of psi.0.samples is an MCMC sample of the psi for one site
# -> these are the means ordered in that vector based on their cell

length(psi.0.mean) #this is mean values across all the cells, so we need a map to interpret it

# Find 95% credible intervals and widths of 95% credible interval for occurrence probability estimates:
quantiles.ordered.samples <- as.data.frame(
  t(apply(psi.0.samples ,2,quantile,probs=c(0.025,0.975))))
quantiles.ordered.samples$width <- quantiles.ordered.samples[,2] -
  quantiles.ordered.samples[,1]

# Predictive plots require the shapefile for the 10x10 grids that can be linked to the unique cell IDs. 

# Create a dataframe for plotting:Plot names in the covariates and in the prediction outputs line up because that is the order it was read into the prediction formula

predicted.df <- data.frame(Cell= occ_covs_all$Cell,
                           psi.mean = psi.0.mean,
                           psi.width = quantiles.ordered.samples$width)

# Join the predicted results to the spatial grid, using the plot name
plottable <- left_join(select(grid_shp,Cell, geometry),
                       predicted.df,
                       by = 'Cell')
# There are some NA grid cells that didn't have covariate values and don't have predictions; remove them: 
plottable <- na.omit(plottable)

ggplot(data = plottable) +
  geom_sf(aes(fill = psi.mean), lwd = 0.05) +
  theme_bw() +
  viridis::scale_fill_viridis(limits = c(0, 1)) +
  ggtitle('LANO posterior mean predicted occurrence',
          'Single-season, single-species model')

ggplot(plottable) +
  geom_sf(aes(fill = psi.width), lwd = 0.05) +
  theme_bw() +
  viridis::scale_fill_viridis(option = 'plasma', limits = c(0, 1)) +
  ggtitle('LANO predicted occurrence 95% interval width',
          'Single-season, single-species model')



# Below we predict across the 400 “new” locations and plot them in comparison to the true values we used to simulate the data.

# Predict occupancy at the 400 new sites
out.pred <- predict(out.svc.trend, X.pred, coords.pred, t.cols = 1:n.time.max)

# get SVC values at the prediction locations
svc.pred.samples <- getSVCSamples(out.svc.trend, pred.object = out.pred)

# Get mean values of the SVC for the covariate
svc.cov.pred.mean <- apply(svc.pred.samples$occ.cov.1, 2, mean)

# Plot
plot(coords.pred, type = "n", xlab = "", ylab = "", asp = TRUE, 
     main = "Estimated values", bty = 'n')
points(coords.pred, pch=15, cex = 2.1, 
       col = rgb(0,0,0,(svc.cov.pred.mean-min(svc.cov.pred.mean))/diff(range(svc.cov.pred.mean))))

## adapt 
# First standardize elevation using mean and sd from fitted model
elev.pred <- (hbefElev$val - mean(btbwHBEF$occ.covs[, 1])) / sd(btbwHBEF$occ.covs[, 1])
coords.0 <- as.matrix(hbefElev[, c('Easting', 'Northing')])
X.0 <- cbind(1, elev.pred, elev.pred^2)
out.pred <- predict(out, X.0, coords.0, verbose = FALSE)

# Plot spatially varying trend across study region  
**FIX THIS**
  
  y <- yarray            #detection-nondetection data
X <- dat$X             #occurrence design matrix for fixed effects
X.p <- dat$X.p         #detection design matrix for fixed effets  
psi <- dat$psi         #occurrence values
coords <- coords       #spatial coordinates
w <- dat$w             #spatially varying intercept and covariate effects
cov.effect <- beta[2] + w[, 2]
plot.dat <- data.frame(x = coords[, 1], 
                       y = coords[, 2], 
                       cov.effect = cov.effect)

ggplot(plot.dat, aes(x = x, y = y, fill = cov.effect)) + 
  geom_raster() + 
  scale_fill_gradient2(midpoint = 0, low = '#B2182B', mid = 'white', 
                       high = '#2166AC', na.value = NA) + 
  theme_bw() 
# (decrease in occurrence = red, increase in occurrence = blue)





## Occurrence data across study area ------------------------------------------

# We may be interested in average occurrence across the whole study area, which can be computed as a derived quantity of the cell-level occurrences. We include naive average occurrence across surveyed cells as a solid line.

psi <- as.data.frame(out$psi.samples) # samples of latent psi across all sites
#this is psi sampled across all 169 sites
avg_psi <- rowMeans(psi) #take averages across all columns (sites)
avg_psi_naive <- mean(as.numeric(as.character(naive$Naive_occupancy))) FIGURE THIS OUT 
hist(avg_psi, breaks = 20, freq=F, main = "", xlab = "Mean occurrence across all cells")
abline(v = avg_psi_naive, lwd = 2) FIGURE THIS OUT 




## add in the following 

## Estimates of SVCs 

# To extract the estimates of the spatially varying coefficients at each of the spatial locations in the data set used to fit the model, we need to combine the non-spatial component of the coefficient (contained in out.svc$beta.samples) and the spatial component of the coefficient (contained in out.svc$w.samples). Recall that in an SVC occupancy model, the total effect of a covariate at any given location is the sum of the non-spatial effect and the adjustment of the effect at that specific location. We provide the function getSVCSamples() to extract the SVCs at each location.

# The resulting object, here called svc.samples, is a list with each component corresponding to a matrix of the MCMC samples of each spatially varying coefficient estimated in the model, with rows corresponding to MCMC sample and column corresponding to site.

svc.samples <- getSVCSamples(out) 
str(svc.samples)

# Intercept 
svc.samples <- getSVCSamples(out.svc.trend)
int.quants <- apply(svc.samples[["(Intercept)"]], 2, quantile, 
                    probs = c(0.025, 0.5, 0.975))
svc.true.fit <- beta + w.fit
plot(svc.true.fit[, 1], int.quants[2, ], pch = 19, 
     ylim = c(min(int.quants[1, ]), max(int.quants[3, ])),
     xlab = "True", ylab = "Fit", main = 'Intercept')
abline(0, 1)
arrows(svc.true.fit[, 1], int.quants[2, ], svc.true.fit[, 1], col = 'gray', 
       int.quants[1, ], length = 0.02, angle = 90)
arrows(svc.true.fit[, 1], int.quants[1, ], svc.true.fit[, 1], col = 'gray', 
       int.quants[3, ], length = 0.02, angle = 90)
points(svc.true.fit[, 1], int.quants[2, ], pch = 19)

# Trend -------------------------------------------------------------------
trend.quants <- apply(svc.samples[["trend"]], 2, quantile, 
                      probs = c(0.025, 0.5, 0.975))
plot(svc.true.fit[, 2], trend.quants[2, ], pch = 19, 
     ylim = c(min(trend.quants[1, ]), max(trend.quants[3, ])),
     xlab = "True", ylab = "Fit", main = 'Spatially-Varying Trends')
abline(0, 1)
arrows(svc.true.fit[, 2], trend.quants[2, ], svc.true.fit[, 2], col = 'gray', 
       trend.quants[1, ], length = 0.02, angle = 90)
arrows(svc.true.fit[, 2], trend.quants[1, ], svc.true.fit[, 2], col = 'gray', 
       trend.quants[3, ], length = 0.02, angle = 90)
points(svc.true.fit[, 2], trend.quants[2, ], pch = 19)


#https://code.usgs.gov/usgs/norock/irvine_k/vignette-bayesian-site-occupancy-model-bat-acoustic-data/-/blob/main/LANO-OR-WA-vignette.pdf?ref_type=heads
#Plotting covariates
ggplot(data = plottable_covs) +
  geom_sf(aes(fill = Forest_PercentCover), lwd = 0.05 ) +
  theme_bw() +
  viridis::scale_fill_viridis(limits = c(0, 1))




# Load full reference grid ---------------------------------------------------------------
grid_full <- rast("/gpfs/gibbs/pi/jetz/wildlife_insights/RWT/data/data_for_annotation/Global_1km_CEA_reference_raster_with_cellID.tif")

# Load range map ---------------------------------------------------------------
file_rangemap <- list.files("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/", full.names = TRUE) %>% 
  str_subset(pattern = species_full)
#rangemap <- rast("/gpfs/gibbs/pi/jetz/data/species_datasets/rangemaps/mammals/mdd_mammals/rasters_cea/Suncus_etruscus.tif")
rangemap <- rast(file_rangemap)
rangemap_bf <- buffer(rangemap, width = 100000) #500 km
rangemap_bf <- as.numeric(rangemap_bf) # from true/false to 1/0
rangemap_bf <- ifel(rangemap_bf == 0, NA, 1)



# Subset grid based on range map -----------------------------------------------
grid_sub <- terra::crop(grid_full, rangemap_bf) # to make extent match
grid_sub <- terra::mask(grid_sub, rangemap_bf) # to mask 

# plot(grid_sub, y = 2)
# plot(rangemap_bf)
# plot(rangemap, add = TRUE, col = "red")
# plot(rangemap_bf, add = TRUE, col = "blue")
# plot(world,  col=NULL, "l", add = TRUE)
# points(coords, col = "blue")


# Remove no-land ---------------------------------------------------------------
land <- rast("/gpfs/gibbs/pi/jetz/data/regions_datasets/MOL_land_layer/v2/MOL_Land_Layer_Countries_Fixed_1km.tiff") %>% 
  terra::project(crs(grid_sub))

land_sub <- terra::crop(land, grid_sub) # to make extent match
land_sub <- ifel(land_sub == 0, NA, 1)
land_sub_rs <- resample(land_sub, grid_sub) # resample to align
grid_land <- terra::mask(grid_sub, land_sub_rs) # to remove no-land 

# Extract covariates -----------------------------------------------------------
