# Project: WI Occupancy Range Wide Trends

# This file contains code to format the data to run species-level occupancy models.

# Set working directory 
rm(list=ls()); gc()
setwd("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights")
set.seed(123)

# Snappy codec
unlink("/gpfs/gibbs/pi/jetz/projects/WildlifeInsights/R/4.2/00LOCK-arrow", recursive = TRUE)
Sys.setenv(ARROW_S3="ON")
Sys.setenv(NOT_CRAN="true")
install.packages("arrow", repos = "https://arrow-r-nightly.s3.amazonaws.com")

# Load libraries
library(arrow)
library(coda)
library(dplyr)
library(forcats)
library(ggmap)
library(gridExtra)
#library(hrbrthemes)
library(lubridate)
library(MCMCvis)
library(purrr)
library(reshape2)
library(rlist)
library(sf)
library(spOccupancy)
library(stringr)
library(tibble)
library(tictoc)
library(tidyr)
library(tidyverse) 
library(tmap)
library(tmaptools)
library(tsibble)
library(viridis)

# Prep detection matrix, effort, and julian date -------------------------------
# Goal: Prep species-specific stacked detection matrices, by deployment-season-year and week

# Load data 
#overview_seq <- open_dataset("WI data/sequences_updated_20240710_parquet")
overview_seq <- read.csv("WI data/sequences_updated_20240710.csv")
#overview_images <- open_dataset("WI data/images_updated_20240714_parquet")
overview_images <- read.csv("WI data/images_updated_20240714.csv")

# Format data
dat_seq <- overview_seq |>
  mutate(record_date = sequence_date) |>
  dplyr::select(-c(sequence_date, sequence_datetime)) |>
  collect()

# if loaded csv: 
dat_seq <- dat_seq %>% 
  dplyr::select(project_id, deployment_location_id, record_date, sensor_start_date_and_time, 
         sensor_end_date_and_time, latitude, longitude, class, sp_binomial)

dat_images <- overview_images |>
  mutate(record_date = photo_date) |>
  mutate(sp_binomial = Accepted_MOL) |>
  dplyr::select(-c(photo_date, photo_datetime, Accepted_MOL)) |>
  collect()

dat_images <- dat_images[!dat_images$sp_binomial == "Accepted_MOL",] |> #header added as row
  mutate(latitude = as.numeric(latitude)) |>
  mutate(longitude = as.numeric(longitude)) 

# if loaded csv: 
dat_images <- dat_images %>% 
  dplyr::select(project_id, deployment_location_id, record_date, sensor_start_date_and_time, 
         sensor_end_date_and_time, latitude, longitude, class, sp_binomial)

# Combine data 
all_dat <- rbind(dat_images, dat_seq) %>% 
  mutate(sensor_start_date = as.Date(sensor_start_date_and_time),
         sensor_end_date = as.Date(sensor_end_date_and_time),
         record_date = as.Date(record_date)) %>% 
  dplyr::select(-c(sensor_start_date_and_time, sensor_end_date_and_time))

all_dat <- all_dat[!is.na(all_dat$record_date),]

rm(dat_seq, dat_images, overview_images, overview_seq)
gc()

# Define periods --------------------------------------------------------------

# Define time in the year-week format 
#all_dat <- all_dat %>% mutate(record_yearweek = yearweek(record_date))

# Create season template
min_year <- 2000  
max_year <- 2024 
range_year <- c(min_year, max_year)
min_date <- as.Date(paste(range_year[1] - 1, "-12-01", sep = ""))
max_date <- as.Date(paste(range_year[2] + 1, "-03-01", sep = "")) 
start_period <-  seq.Date(min_date, max_date, by =  "91 day") #"3 month"
end_period <-  c(start_period[-1] - 1, NA)

periods <- data.frame(period = paste("Period", seq(1, length(start_period), by = 1), sep = "_"),
                      start_period = start_period, 
                      end_period = end_period) 
periods <- periods[-nrow(periods),]
periods$season <- rep(c("Winter", "Spring", "Summer", "Fall"), length.out = nrow(periods))
periods$year <- year(periods$start_period)
periods$period_counter <- 1:nrow(periods)
head(periods)

# Add initial info ------------------------------------------------------------

# Target species name
target_species <- "Helarctos malayanus"

# extract data for a species
dat_sp <- all_dat %>% filter(sp_binomial == target_species)

# retain all records of the projects in which the target species was detected
dat <- all_dat %>% filter(project_id %in% unique(dat_sp$project_id)) 

# Data exploration & cleaning -------------------------------------------------

if(data_exploration){
  # Spatial and temporal checks ---------------------------------------------
  # Spatial coverage
  # Select unique locations
  loc <- dat %>% 
    dplyr::select(latitude, longitude, project_id) %>% 
    distinct() %>% 
    mutate(project_id = as.factor(project_id))
  
  # EXAMINE DATA -> manually update 
  loc <- loc %>% filter(longitude != max(longitude)) #remove weird location
  
  # Create spatial object and set CRS (WGS84)
  loc_sp <- st_as_sf(loc, coords = c("longitude", "latitude"), remove = FALSE)
  st_crs(loc_sp) = 4326
  
  # Map locations
  data("World")
  World <- st_transform(World, crs = 4326)
  #tmap_mode("view")
  tmap_mode("plot")
  dat_map_range <- tm_shape(loc_sp) +
    tm_grid() +
    tm_dots(col = "project_id", popup.vars=c("Lat" = "latitude", "Long" = "longitude"), 
            size = 0.3) +
    #tm_compass(type = "8star", position = c("right", "top")) +
    tm_scale_bar(breaks = c(0, 500, 1000), text.size = 1, position = c("LEFT", "BOTTOM")) +
    tm_style("col_blind") + # + tm_basemap(server = "OpenTopoMap")
    tm_shape(World) +
    tm_fill(alpha = 0.3) +
    tm_borders() +
    tm_layout(legend.show = FALSE) #legend.outside = TRUE)       
  print(dat_map_range)
  
  # Map locations --- NOT WORKING; HOW DIFFERENT FROM ABOVE? LOOK AT LATER 
  data("World")
  World <- st_transform(World, crs = 4326)
  #tmap_mode("view")
  tmap_mode("plot")
  dat_map_proj <- tm_shape(loc_sp) +
    tm_grid() +
    tm_dots(popup.vars=c("Lat" = "latitude", "Long" = "longitude"), size = 0.3) +
    tm_facets(by = "project_id") +
    tm_scale_bar(breaks = c(0, 5, 10), text.size = 1, position = c("LEFT", "BOTTOM")) +
    tm_style("col_blind") 
  print(dat_map_proj)
  
  # Temporal coverage
  dat_temp <- dat %>% mutate(record_week = sprintf("%02d", week(record_date)),
                             record_year = year(record_date),
                             year_week = as.numeric(paste(record_year, record_week, sep = "")),
                             proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
    dplyr::select(project_id, deployment_location_id, proj_depl, year_week) %>% distinct()
  
  x_label <- (expand.grid(year = seq(year(min(dat$record_date)), year(max(dat$record_date)), by = 1),
                          week = sprintf("%02d", seq(01, 53, 1))) %>% 
                mutate(x_label = paste(year, week, sep = "")) %>% 
                arrange(x_label))$x_label
  
  dat_sp_temp <- dat_sp %>% mutate(record_week = sprintf("%02d", week(record_date)),
                                   record_year = year(record_date),
                                   year_week = as.numeric(paste(record_year, record_week, sep = "")),
                                   proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
    dplyr::select(project_id, deployment_location_id, proj_depl, year_week) %>% distinct()
  
  ggplot(dat_temp, aes(x = as.factor(year_week), y = proj_depl, group = as.factor(project_id))) +
    geom_point(aes(color = as.factor(project_id))) +
    geom_point(data = dat_sp_temp, aes(x = as.factor(year_week), y = proj_depl, group = as.factor(project_id)),
               color = "black", inherit.aes = FALSE) +
    scale_x_discrete("Year-week", breaks = as.factor(x_label[seq(1, length(x_label), by = 8)]), 
                     labels = as.factor(x_label[seq(1, length(x_label), by = 8)])) +
    labs(y = "Deployments", title = target_species) +
    theme_classic() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
          axis.title = element_text(face = "bold"),
          legend.position = "none")
}

# After doing checks, clean original data for outliers 
#dat_sp <- dat_sp %>% filter(longitude != max(longitude)) #remove weird location
#dat <- dat %>% filter(longitude != max(longitude)) #remove weird location


## Build camera operability matrix (effort) -----------------------------------

# Start and ending dates for each project_deployment
proj_depl <- dat %>% 
  mutate(proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
  dplyr::select(proj_depl, sensor_start_date, sensor_end_date) %>% 
  distinct() %>% 
  drop_na() %>% # to remove depl with NAs in start/end sampling
  filter(sensor_start_date >= min_date & sensor_end_date <= max_date)

# List of project_deployments
proj_depl_unique <- unique(proj_depl$proj_depl)

# Days from start to end project
sampling_dates <- seq.Date(periods[1,2], periods[nrow(periods),3], by = "1 days")

# Create empty matrix, add colummn and row names
cam_op <- matrix(NA, nrow = length(proj_depl_unique), 
                 ncol = length(sampling_dates))
colnames(cam_op) <- as.character(sampling_dates)
rownames(cam_op) <- proj_depl_unique

# Fill matrix with 1 when cameras were active
for(i in 1:nrow(proj_depl)){
  cam_op[proj_depl$proj_depl[i], 
         as.character(seq.Date(as.Date(proj_depl$sensor_start_date[i]), 
                               as.Date(proj_depl$sensor_end_date[i]), 
                               by =  1))] <- 1
} 
sum(cam_op,na.rm=T) #check if working 

if(data_exploration){ 
  eff <- data.frame(active_depl = colSums(cam_op, na.rm = TRUE), sampl_date = as.Date(colnames(cam_op)))
  ggplot() +
    geom_col(data = eff, aes(x = sampl_date, y = active_depl), col = "royalblue") +
    geom_vline(xintercept = c(periods$start_period, periods$end_period[nrow(periods)]), linetype = "dashed",
               color = "grey56") +
    labs(x = "Date", y = "Number of active deployments", title = target_species) +
    theme_bw()
}

## Build Julian date matrix ---------------------------------------------------

juldat <- matrix(rep(yday(colnames(cam_op)), nrow(cam_op)), 
                 ncol = ncol(cam_op),
                 byrow = TRUE)
colnames(juldat) <- colnames(cam_op)
rownames(juldat) <- rownames(cam_op)

## Build detection/non-detection matrix ----------------------------------------

# Prepare matrix
det_mat <- cam_op

# Replace 1s with 0s (camera on; set baselien as non-detections) 
det_mat[det_mat == 1] <- 0   

# Remove records without effort information
dat_sp <- dat_sp %>% 
  filter(paste(project_id, deployment_location_id, sep = "_") %in% proj_depl_unique)

# Fill in detections 
dat_sp$proj_depl <- paste(dat_sp$project_id, dat_sp$deployment_location_id, sep = "_")
for(i in 1:nrow(dat_sp)){
  det_mat[dat_sp$proj_depl[i], as.character(dat_sp$record_date[i])] <- 1
} 

# Check 
table(det_mat) 

## Organize in periods -------------------------------------------------------- 

# Detection/non-detection -----------------------------------------------------

# Prepare list to store detection matrix by period
det_ls <- vector("list", length = nrow(periods))

# Split detection/non-detection matrix by period
for (i in 1:nrow(periods)){
  det_ls[[i]] <- det_mat[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                                 as.Date(periods$end_period[i]), 
                                                 by = "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Set max length to 13 weeks x 7 days = 91 
max.length <- 91 

# Remove columns if more that max.length
for(i in 1:length(det_ls)){
  if(ncol(det_ls[[i]]) > max.length){
    det_ls[[i]] <- det_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
det_ls <- lapply(det_ls, function(v) {cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(det_ls, dim))

# Add info about season, year
for(i in 1:length(det_ls)) {
  det_ls[[i]] <- cbind(det_ls[[i]], 
                       cbind(rep(periods$season[i], nrow(det_ls[[i]])), 
                             rep(year(periods$start_period[i]), nrow(det_ls[[i]]))))
  colnames(det_ls[[i]])[(max.length+1):(max.length+2)] <- c("season", "year")
}

# Unlist detection histories 
det_mat <- list.rbind(det_ls)  

## Effort ---------------------------------------------------------------------

# Prepare list to store cam_op (i.e. effort) by period
cam_op_ls <- vector("list", length = nrow(periods))

# split cam_op matrix by period
for (i in 1:nrow(periods)){
  cam_op_ls[[i]] <- cam_op[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                                   as.Date(periods$end_period[i]), 
                                                   by = "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Set max length to 13 weeks x 7 days = 91 
max.length <- 91

# Remove columns if more that max.length
for(i in 1:length(cam_op_ls)){
  if(ncol(cam_op_ls[[i]]) > max.length){
    cam_op_ls[[i]] <- cam_op_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
cam_op_ls <- lapply(cam_op_ls, function(v) { cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(cam_op_ls, dim))

# Add info about season, year
for(i in 1:length(cam_op_ls)) {
  cam_op_ls[[i]] <- cbind(cam_op_ls[[i]], 
                          cbind(rep(periods$season[i], nrow(cam_op_ls[[i]])), 
                                rep(year(periods$start_period[i]), nrow(cam_op_ls[[i]]))))
  colnames(cam_op_ls[[i]])[(max.length+1):(max.length+2)] <- c("season", "year")
}

# Unlist detection histories
cam_op <- list.rbind(cam_op_ls) 

## Julian date ----------------------------------------------------------------

# Prepare list to store juldat by period
juldat_ls <- vector("list", length = nrow(periods))

# Split juldat matrix by period
for (i in 1:nrow(periods)){
  juldat_ls[[i]] <- juldat[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                                   as.Date(periods$end_period[i]), 
                                                   by =  "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Set max length to 13 weeks x 7 days = 91 
max.length <- 91

# Remove columns if more that max.length
for(i in 1:length(juldat_ls)){
  if(ncol(juldat_ls[[i]]) > max.length){
    juldat_ls[[i]] <- juldat_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
juldat_ls <- lapply(juldat_ls, function(v) { cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(juldat_ls, dim))

# Unlist detection histories
juldat <- list.rbind(juldat_ls)  

## Remove deployment-season combinations with no effort -----------------------
ind <- apply(cam_op[,1:max.length], 1, function(x) all(is.na(x)))
cam_op <- cam_op[!ind, ]
det_mat <- det_mat[!ind, ]
juldat <- juldat[!ind, ]

## Aggregate in weekly occasions ----------------------------------------------

# Detection/non-detection -----------------------------------------------------
det_sub <- data.frame(apply(as.data.frame(det_mat[, 1:(ncol(det_mat)-2)]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(det_sub)+1), 7)
ystack <- matrix(NA, nrow = nrow(det_sub), ncol = length(indx)-1)

for(i in 1:(length(indx)-1)) {
  temp <- det_sub[,indx[i]:(indx[i+1]-1)]
  ystack[,i] <- apply(temp, 1, function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE)))
}

# Effort ------------------------------------------------------------------ 
cam_op_sub <- data.frame(apply(as.data.frame(cam_op[, 1:(ncol(cam_op)-2)]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(cam_op_sub)+1), 7)
effort <- matrix(NA, nrow = nrow(cam_op_sub), ncol = length(indx)-1)

for(i in 1:(length(indx)-1)) {
  temp <- cam_op_sub[,indx[i]:(indx[i+1]-1)]
  effort[,i] <- apply(temp, 1, function(x) ifelse(all(is.na(x)), NA, sum(x, na.rm = TRUE)))
}
effort <- as.data.frame(effort)
colnames(effort) <- paste("effort_w", seq(1, ncol(effort), 1), sep = "")

# Minimum Julian date ----------------------------------------------------- 
juldat_sub <- data.frame(apply(as.data.frame(juldat[, 1:(ncol(juldat))]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(juldat_sub)+1), 7)
minjul <- matrix(NA, nrow = nrow(juldat_sub), ncol = length(indx)-1)
for(i in 1:(length(indx)-1)) {
  temp <- juldat_sub[,indx[i]:(indx[i+1]-1)]
  minjul[,i] <- apply(temp, 1, function(x) min(x, na.rm = TRUE))
}
minjul <- as.data.frame(minjul)
colnames(minjul) <- paste("minjul_w", seq(1, ncol(minjul), 1), sep = "")

# Remove deployment-season with less than two weeks of sampling
ind <- apply(effort[,1:13], 1, function(x) sum(!is.na(x)))
effort <- effort[ind > 1, ]
ystack <- ystack[ind > 1, ]
det_mat <- det_mat[ind > 1, ]
minjul <- minjul[ind > 1, ]

## Prepare covariates related to sampling -------------------------------------

# Add season/time covariates (?)
covs <- cbind(effort, minjul) %>% 
  mutate(proj_depl = rownames(det_mat),
         season = det_mat[, ncol(det_mat)-1],
         year = det_mat[, ncol(det_mat)],
         proj = substr(proj_depl, 1, 7),
         depl = substr(proj_depl, 9, nchar(proj_depl)))

if(data_exploration){
  # Visualize effort
  covs_long <- covs %>% 
    select(proj_depl, season, year, effort_w1:effort_w13) %>% 
    mutate(proj_depl_s_y = paste(proj_depl, season, year, sep = "_")) %>% 
    select(-c("proj_depl", "season", "year")) %>% 
    pivot_longer(!proj_depl_s_y, names_to = "effort_week", values_to = "effort") %>% 
    mutate_at(vars(effort_week), ~fct_relevel(., c("effort_w1", "effort_w2", "effort_w3",
                                                   "effort_w4", "effort_w5", "effort_w6",
                                                   "effort_w7", "effort_w8", "effort_w9",
                                                   "effort_w10", "effort_w11", "effort_w12",
                                                   "effort_w13")))
  
  ggplot(covs_long, aes(x = effort_week, y = proj_depl_s_y, color = as.factor(effort), 
                        fill = as.factor(effort))) +
    geom_tile() +
    theme_bw() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
  
  # Visualize detection/nondetection matrices
  ystack_long <- as.data.frame(ystack) %>% 
    mutate(proj_depl_s_y = with(covs, paste(proj_depl, season, year, sep = "_")),
           season_year = with(covs, paste(season, year, sep = "_"))) %>% 
    pivot_longer(!c(proj_depl_s_y, season_year), names_to = "det_week", values_to = "det") %>% 
    mutate_at(vars(det_week), ~fct_relevel(., c("V1", "V2", "V3", "V4", "V5",
                                                "V6", "V7", "V8", "V9", "V10",
                                                "V11", "V12", "V13"))) 
  
  ggplot(ystack_long, aes(x = det_week, y = proj_depl_s_y, color = as.factor(det), 
                          fill = as.factor(det))) +
    geom_tile() +
    scale_fill_manual(values = c("black", "red", "white")) +
    labs(x="Week", y="Proj_depl_season_year", title="Detection matrices") +
    theme_bw() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    facet_wrap(~season_year)
}

# Add period counter
covs <- left_join(covs, periods %>% 
                    dplyr::select("season", "year", "period_counter") %>% 
                    mutate(year = as.character(year)))

## Spatially aggregate to cell ID ---------------------------------------------

coords <- read.csv("10x10 km spatial layers/WI_loc_matching_cell_ID.csv") %>% 
  mutate(proj_depl = paste(project_id, deployment_location_id, sep="_")) %>% 
  dplyr::select(-c(project_id, deployment_location_id)) %>% 
  distinct()
covs <- left_join(covs, coords, by = "proj_depl")

# Quick check 
sum(is.na(covs$cell_ID))

ystack2 <- as.data.frame(ystack) 
ystack2 <- cbind(ystack2, covs)

test <- ystack2 #quick save - good through here; afterwards, things get weird 

ystack2_group <- ystack2 %>% 
  drop_na(cell_ID) %>% 
  group_by(cell_ID, season, `year`) %>% 
  summarise(n_depl = n(),
            across(starts_with("V"), function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE))),
            across(starts_with("effort_w"), function(x) ifelse(all(is.na(x)), NA, sum(x, na.rm = TRUE))),
            across(minjul_w1:minjul_w13, min),
            proj = unique(proj),
            period_counter = unique(period_counter)) %>% 
  ungroup() 

# -> more than 7 days effort because combining effort from multiple project-deployments within same 
# cell_ID (e.g., if 6 projects each operating for full 7 days, effort is 42)

# Reorganize outputs for modeling
ystack <- ystack2_group %>% dplyr::select(V1:V13)
covs <- ystack2_group %>% dplyr::select(-(V1:V13))

filename <- paste("Data for modelling/", target_species, "_", Sys.Date(), ".RData", sep = "")
save(ystack, covs, target_species, file = filename)
