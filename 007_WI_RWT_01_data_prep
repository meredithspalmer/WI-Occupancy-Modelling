# Project: WI Occupancy Range Wide Trends

# This file contains code to format the data to run species-level occupancy models.

# Set working directory 
rm(list=ls())
setwd("/gpfs/gibbs/project/jetz/msp69/WI_2024/Wildlife Insights Data_2024")
set.seed(123)

# Load libraries
library(arrow)
library(tidyverse) 
library(sf)
library(ggmap)
library(tmap)
library(tmaptools)
library(lubridate)
library(tictoc)
library(reshape2)
library(gridExtra)
library(tsibble)
library(rlist)
library(hrbrthemes)
library(viridis)

# Prep detection matrix, effort, and julian date -------------------------------
# Goal: Prep species-specific stacked detection matrices, by deployment-season-year and week

# Specify species in the format "Genus species"
species_name <- "Eira barbara"

# Load data 
overview_seq <- open_dataset("sequences")
overview_images <- open_dataset("images")

# select data
dat_seq <- overview_seq |>
  filter(Accepted_MOL == species_name) |> 
  mutate(record_date = sequence_date_fix) |>
  dplyr::select(-sequence_date_fix) |>
  collect()
dat_images <- overview_images |>
  filter(Accepted_MOL == species_name) |>
  mutate(record_date = photo_date) |>
  dplyr::select(-photo_date) |>
  collect()

all_dat <- rbind(dat_images, dat_seq) %>% 
  mutate(sensor_start_date = as.Date(sensor_start_date_and_time),
         sensor_end_date = as.Date(sensor_end_date_and_time),
         latitude = as.numeric(latitude_fix),
         longitude = as.numeric(longitude_fix),
         record_date = as.Date(record_date)) %>% 
  dplyr::select(-c(sensor_start_date_and_time, sensor_end_date_and_time, latitude_fix, longitude_fix))
nrow(all_dat)

# Create detection-non detection matrix ---------------------------------------

# Sampling units are defined as project-deployment-season-year; occasions are defined 
# as 1-week long for a total of 13 week for each season-year (i.e. 13 weeks x 7 days 
# = 91 days). Sampling units sampled less than two weeks are removed from the matrices. 
# Seasons are defined as:
# * Winter: Dec - Feb
# * Spring: March - May
# * Summer: June - Aug
# * Fall: Sept - Nov

# If spatial_aggreg = TRUE, data from single camera trap location are aggregated at 
# grid level. 

# @param target_species chr. Specify species in the format "Genus species". 
# @param data_exploration logic. When TRUE, effort and detection will be plotted  
data_exploration <- FALSE
# @param spatial_aggreg logic. When TRUE, data are aggregated at grid level  
spatial_aggreg <- TRUE

# Add initial info ------------------------------------------------------

# store species name
species <- target_species <- species_name

# extract data for a species
dat_sp <- all_dat %>% filter(Accepted_MOL == target_species)

# Number of records
message("Number of records: ", nrow(dat_sp))

# retain all records of the projects in which the target species was detected
dat <- all_dat %>% filter(project_id %in% unique(dat_sp$project_id)) 

# Data cleaning ----------------------------------------------------------

if(data_exploration){
  
  # Spatial and temporal checks ---------------------------------------------
  # Spatial coverage
  # Select unique locations
  loc <- dat %>% select(latitude, longitude, project_id) %>% distinct()
  loc <- loc %>% filter(longitude != max(longitude)) %>% #remove weird location
    mutate(project_id = as.factor(project_id))
  # Create spatial object and set CRS (WGS84)
  loc_sp <- st_as_sf(loc, coords = c("longitude", "latitude"), remove = FALSE)
  st_crs(loc_sp) = 4326
  
  # Map locations
  data("World")
  World <- st_transform(World, crs = 4326)
  #tmap_mode("view")
  tmap_mode("plot")
  dat_map_range <- tm_shape(loc_sp) +
    tm_grid() +
    tm_dots(col = "project_id", popup.vars=c("Lat" = "latitude", "Long" = "longitude"), 
            size = 0.3) +
    tm_compass(type = "8star", position = c("right", "top")) +
    tm_scale_bar(breaks = c(0, 500, 1000), text.size = 1, position = c("LEFT", "BOTTOM")) +
    tm_style("col_blind") + # + tm_basemap(server = "OpenTopoMap")
    tm_shape(World) +
    tm_fill(alpha = 0.3) +
    tm_borders() +
    tm_layout(legend.outside = TRUE)       
  print(dat_map_range)
  
  # Map locations
  data("World")
  World <- st_transform(World, crs = 4326)
  #tmap_mode("view")
  tmap_mode("plot")
  dat_map_proj <- tm_shape(loc_sp) +
    tm_grid() +
    tm_dots(popup.vars=c("Lat" = "latitude", "Long" = "longitude"), size = 0.3) +
    tm_facets(by = "project_id") +
    tm_scale_bar(breaks = c(0, 5, 10), text.size = 1, position = c("LEFT", "BOTTOM")) +
    tm_style("col_blind") 
  print(dat_map_proj)
  
  # Temporal coverage
  dat_temp <- dat %>% mutate(record_week = sprintf("%02d", week(record_date)),
                             record_year = year(record_date),
                             year_week = as.numeric(paste(record_year, record_week, sep = "")),
                             proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
    select(project_id, deployment_location_id, proj_depl, year_week) %>% distinct()
  x_label <- (expand.grid(year = seq(year(min(dat$record_date)), year(max(dat$record_date)), by = 1),
                          week = sprintf("%02d", seq(01, 53, 1))) %>% 
                mutate(x_label = paste(year, week, sep = "")) %>% 
                arrange(x_label))$x_label
  dat_sp_temp <- dat_sp %>% mutate(record_week = sprintf("%02d", week(record_date)),
                                   record_year = year(record_date),
                                   year_week = as.numeric(paste(record_year, record_week, sep = "")),
                                   proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
    select(project_id, deployment_location_id, proj_depl, year_week) %>% distinct()
  ggplot(dat_temp, aes(x = as.factor(year_week), y = proj_depl, group = as.factor(project_id))) +
    geom_point(aes(color = as.factor(project_id))) +
    geom_point(data = dat_sp_temp, aes(x = as.factor(year_week), y = proj_depl, group = as.factor(project_id)),
               color = "black", inherit.aes = FALSE) +
    scale_x_discrete("Year-week", breaks = as.factor(x_label[seq(1, length(x_label), by = 8)]), 
                     labels = as.factor(x_label[seq(1, length(x_label), by = 8)])) +
    labs(y = "Deployments", title = species) +
    theme_classic() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
          axis.title = element_text(face = "bold"),
          legend.position = "none")
}

# Data formatting --------------------------------------------------------

# Define periods --------------------------------------------------------
# Format data for analysis in stacked occupancy model
# Define time in the year-week format 
dat <- dat %>% 
  mutate(record_yearweek = yearweek(record_date))

# Define seasonal periods
#* Winter: Dec - Feb
#* Spring: March - May
#* Summer: June - Aug
#* Fall: Sept - Nov

# Define year-long periods
#* year range 
range_year <- year(range(dat$record_date))

# range (+1 to accommodate last year records) 
min_date <- as.Date(paste(range_year[1] - 1, "-12-01", sep = ""))
max_date <- as.Date(paste(range_year[2] + 1, "-03-01", sep = "")) 
^ MAY NEED TO UPDATED THIS MONTH; why this particular date? 
  
  # build data.frame
  start_period <-  seq.Date(min_date, max_date, by =  "3 month")
end_period <-  c(start_period[-1] - 1, NA)
periods <- data.frame(period = paste("Period", seq(1, length(start_period), by = 1), sep = "_"),
                      start_period = start_period, 
                      end_period = end_period) 
# remove last row
periods <- periods[-nrow(periods),]

# add info about season
periods$season <- rep(c("Winter", "Spring", "Summer", "Fall"), length.out = nrow(periods))

# add info about year
periods$year <- year(periods$start_period)

# add period counter (for autologistic process within occupancy model)
periods$period_counter <- 1:nrow(periods)

# Build  -------------------------------------------------------------------
## Camera-operability matrix ----------------------------------------------- 
# start and ending dates for each project_deployment
proj_depl <- dat %>% 
  mutate(proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
  dplyr::select(proj_depl, sensor_start_date, sensor_end_date) %>% 
  distinct() %>% 
  drop_na() %>% # to remove depl with NAs in start/end sampling
  filter(sensor_start_date >= min_date & sensor_end_date <= max_date)

# list of project_deployments
proj_depl_unique <- unique(proj_depl$proj_depl)

# days from start to end project
sampling_dates <- seq.Date(periods[1,2], periods[nrow(periods),3], by =  "1 days")

# create empty matrix, add colummn and row names
cam_op <- matrix(NA, nrow = length(proj_depl_unique), 
                 ncol = length(sampling_dates))
colnames(cam_op) <- as.character(sampling_dates)
rownames(cam_op) <- proj_depl_unique

# fill matrix with 1 when cameras were active
for(i in 1:nrow(proj_depl)){
  cam_op[proj_depl$proj_depl[i], 
         as.character(seq.Date(as.Date(proj_depl$sensor_start_date[i]), 
                               as.Date(proj_depl$sensor_end_date[i]), 
                               by =  1))] <- 1
} 

if(data_exploration){
  # Explore effort
  eff <- data.frame(active_depl = colSums(cam_op, na.rm = TRUE), sampl_date = as.Date(colnames(cam_op)))
  ggplot() +
    geom_col(data = eff, aes(x = sampl_date, y = active_depl), col = "royalblue") +
    geom_vline(xintercept = c(periods$start_period, periods$end_period[nrow(periods)]), linetype = "dashed",
               color = "grey56") +
    labs(x = "Date", y = "Number of active deployments", title = species) +
    theme_bw()
  #ggsave(filename = "figures/Effort.jpg", device = "jpeg", units = "cm", 
  #       width = 50, height = 40, dpi = 300)
}

## Julian date matrix -----------------------------------------------------
# create matrix containing julian dates
juldat <- matrix(rep(yday(colnames(cam_op)), nrow(cam_op)), 
                 ncol = ncol(cam_op),
                 byrow = TRUE)
colnames(juldat) <- colnames(cam_op)
rownames(juldat) <- rownames(cam_op)

## Detection/nondetection matrix --------------------------------------
# prepare matrix
det <- cam_op

# replace 1s with 0s (non-detections)
det[det == 1] <- 0   

# remove records without effort information
dat_sp <- dat_sp %>% 
  filter(paste(project_id, deployment_location_id, sep = "_") %in% proj_depl_unique)

# fill-in detection
for(i in 1:nrow(dat_sp)){
  det[paste(dat_sp$project_id[i], dat_sp$deployment_location_id[i], sep = "_"), 
      as.character(dat_sp$record_date[i])] <- 1
}

# Organize in periods -------------------------------------------------- 
## Detection/non-detection ----------------------------------------------
# prepare list to store detection matrix by period
det_ls <- vector("list", length = nrow(periods))

# split detection/non-detection matrix by period
for (i in 1:nrow(periods)){
  det_ls[[i]] <- det[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                             as.Date(periods$end_period[i]), 
                                             by =  "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Make max.length 91 (= 13 x 7days)
max.length <- 91
# remove columns if more that max.length
for(i in 1:length(det_ls)){
  if(ncol(det_ls[[i]]) > max.length){
    det_ls[[i]] <- det_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
det_ls <- lapply(det_ls, function(v) { cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(det_ls, dim))

# Add info about season, year
for(i in 1:length(det_ls)) {
  det_ls[[i]] <- cbind(det_ls[[i]], 
                       cbind(rep(periods$season[i], nrow(det_ls[[i]])), 
                             rep(year(periods$start_period[i]), nrow(det_ls[[i]]))))
  colnames(det_ls[[i]])[(max.length+1):(max.length+2)] <- c("season", "year")
}

# Unlist detection histories
det <- list.rbind(det_ls)


## Effort ------------------------------------------------------------------
# prepare list to store cam_op (i.e. effort) by period
cam_op_ls <- vector("list", length = nrow(periods))

# split cam_op matrix by period
for (i in 1:nrow(periods)){
  cam_op_ls[[i]] <- cam_op[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                                   as.Date(periods$end_period[i]), 
                                                   by =  "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Make max.length 91 (= 13 x 7days)
max.length <- 91

# remove columns if more that max.length
for(i in 1:length(cam_op_ls)){
  if(ncol(cam_op_ls[[i]]) > max.length){
    cam_op_ls[[i]] <- cam_op_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
cam_op_ls <- lapply(cam_op_ls, function(v) { cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(cam_op_ls, dim))

#' Add info about season, year
for(i in 1:length(cam_op_ls)) {
  cam_op_ls[[i]] <- cbind(cam_op_ls[[i]], 
                          cbind(rep(periods$season[i], nrow(cam_op_ls[[i]])), 
                                rep(year(periods$start_period[i]), nrow(cam_op_ls[[i]]))))
  colnames(cam_op_ls[[i]])[(max.length+1):(max.length+2)] <- c("season", "year")
  
}

# Unlist detection histories
cam_op <- list.rbind(cam_op_ls)

## Julian date -----------------------------------------------------------
# prepare list to store juldat by period
juldat_ls <- vector("list", length = nrow(periods))

# split juldat matrix by period
for (i in 1:nrow(periods)){
  juldat_ls[[i]] <- juldat[, as.character(seq.Date(as.Date(periods$start_period[i]), 
                                                   as.Date(periods$end_period[i]), 
                                                   by =  "1 days"))]
}

# Make ncol even across year-season by adding NAs columns
# Make max.length 91 (= 13 x 7days)
max.length <- 91

# remove columns if more that max.length
for(i in 1:length(juldat_ls)){
  if(ncol(juldat_ls[[i]]) > max.length){
    juldat_ls[[i]] <- juldat_ls[[i]][, 1:max.length]
  }
}

# Add NA columns to list elements
juldat_ls <- lapply(juldat_ls, function(v) { cbind(v, matrix(NA, nrow = nrow(v), ncol = max.length-ncol(v)))})

# Check that all items in list have same dimensions
unlist(sapply(juldat_ls, dim))

# Unlist detection histories
juldat <- list.rbind(juldat_ls)

# Remove deployment-season combinations with no effort
ind <- apply(cam_op[,1:max.length], 1, function(x) all(is.na(x)))
cam_op <- cam_op[!ind, ]
det <- det[!ind, ]
juldat <- juldat[!ind, ]


## Aggregate in weekly occasions --------------------------------------------

# Detection/non-detection --------------------------------------------------
det_sub <- data.frame(apply(as.data.frame(det[, 1:(ncol(det)-2)]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(det_sub)+1), 7)
ystack <- matrix(NA, nrow = nrow(det_sub), ncol = length(indx)-1)
for(i in 1:(length(indx)-1)) {
  temp <- det_sub[,indx[i]:(indx[i+1]-1)]
  ystack[,i] <- apply(temp, 1, function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE)))
}

# Effort ------------------------------------------------------------------ 
cam_op_sub <- data.frame(apply(as.data.frame(cam_op[, 1:(ncol(cam_op)-2)]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(cam_op_sub)+1), 7)
effort <- matrix(NA, nrow = nrow(cam_op_sub), ncol = length(indx)-1)
for(i in 1:(length(indx)-1)) {
  temp <- cam_op_sub[,indx[i]:(indx[i+1]-1)]
  effort[,i] <- apply(temp, 1, function(x) ifelse(all(is.na(x)), NA, sum(x, na.rm = TRUE)))
}
effort <- as.data.frame(effort)
colnames(effort) <- paste("effort_w", seq(1, ncol(effort), 1), sep = "")

# Minimum julian date ----------------------------------------------------- 
juldat_sub <- data.frame(apply(as.data.frame(juldat[, 1:(ncol(juldat))]), 2, as.numeric))
indx <- seq(1, ceiling(ncol(juldat_sub)+1), 7)
minjul <- matrix(NA, nrow = nrow(juldat_sub), ncol = length(indx)-1)
for(i in 1:(length(indx)-1)) {
  temp <- juldat_sub[,indx[i]:(indx[i+1]-1)]
  minjul[,i] <- apply(temp, 1, function(x) min(x, na.rm = TRUE))
}
minjul <- as.data.frame(minjul)
colnames(minjul) <- paste("minjul_w", seq(1, ncol(minjul), 1), sep = "")

# Remove deployment-season with less than two weeks of sampling
ind <- apply(effort[,1:13], 1, function(x) sum(!is.na(x)))
effort <- effort[ind > 1, ]
ystack <- ystack[ind > 1, ]
det <- det[ind > 1, ]
minjul <- minjul[ind > 1, ]

## Prepare covariates related to sampling ----------------------------------------
covs <- cbind(effort, minjul) %>% 
  mutate(proj_depl = rownames(det),
         season = det[, ncol(det)-1],
         year = det[, ncol(det)],
         proj = substr(proj_depl, 1, 7),
         depl = substr(proj_depl, 9, nchar(proj_depl)))

if(data_exploration){
  # Visualize effort
  covs_long <- covs %>% 
    select(proj_depl, season, year, effort_w1:effort_w13) %>% 
    mutate(proj_depl_s_y = paste(proj_depl, season, year, sep = "_")) %>% 
    select(-c("proj_depl", "season", "year")) %>% 
    pivot_longer(!proj_depl_s_y, names_to = "effort_week", values_to = "effort") %>% 
    mutate_at(vars(effort_week), ~fct_relevel(., c("effort_w1", "effort_w2", "effort_w3",
                                                   "effort_w4", "effort_w5", "effort_w6",
                                                   "effort_w7", "effort_w8", "effort_w9",
                                                   "effort_w10", "effort_w11", "effort_w12",
                                                   "effort_w13")))
  
  ggplot(covs_long, aes(x = effort_week, y = proj_depl_s_y, color = as.factor(effort), 
                        fill = as.factor(effort))) +
    geom_tile() +
    theme_bw() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
  
  
  # Visualize detection/nondetection matrices
  ystack_long <- as.data.frame(ystack) %>% 
    mutate(proj_depl_s_y = with(covs, paste(proj_depl, season, year, sep = "_")),
           season_year = with(covs, paste(season, year, sep = "_"))) %>% 
    pivot_longer(!c(proj_depl_s_y, season_year), names_to = "det_week", values_to = "det") %>% 
    mutate_at(vars(det_week), ~fct_relevel(., c("V1", "V2", "V3", "V4", "V5",
                                                "V6", "V7", "V8", "V9", "V10",
                                                "V11", "V12", "V13"))) 
  
  ggplot(ystack_long, aes(x = det_week, y = proj_depl_s_y, color = as.factor(det), 
                          fill = as.factor(det))) +
    geom_tile() +
    scale_fill_manual(values = c("black", "red", "white")) +
    labs(x="Week", y="Proj_depl_season_year", title="Detection matrices") +
    theme_bw() +
    theme(axis.text.y = element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    facet_wrap(~season_year)
}

## add period counter
covs <- left_join(covs, periods %>% 
                    dplyr::select("season", "year", "period_counter") %>% 
                    mutate(year = as.character(year)))

## add lat/long info -------------------------------------------------------
# extract coords by project and deployment. In case of multiple lat/long for a 
# proj_depl, only first set is retained
coords <-  dat %>% 
  dplyr::select(project_id, deployment_location_id, latitude, longitude) %>% 
  distinct(project_id, deployment_location_id, .keep_all = TRUE) %>% 
  mutate(proj_depl = paste(project_id, deployment_location_id, sep = "_")) %>% 
  dplyr::select(-c(project_id, deployment_location_id))

nrow(coords) 
length(unique(covs$proj_depl))

# merge
covs <- left_join(covs, coords, by = "proj_depl")

if(spatial_aggreg){
  
  cell_ID <- read.csv("proj_depl_level_covariates.csv") %>% 
    select(-c(latitude, longitude, project_id))
  #these are static covs for each proj_depl, so join by proj_depl rather than long/lat 
  
  ystack2 <- as.data.frame(ystack) 
  ystack2 <- cbind(ystack2, covs) %>% 
    left_join(cell_ID, by = c("proj_depl"))
  
  ystack2_group <- ystack2 %>% 
    drop_na(cellID) %>% 
    group_by(cellID, season, `year`) %>% 
    summarise(n_depl = n(),
              across(starts_with("V"), function(x) ifelse(all(is.na(x)), NA, max(x, na.rm = TRUE))),
              across(starts_with("effort_w"), function(x) ifelse(all(is.na(x)), NA, sum(x, na.rm = TRUE))),
              across(minjul_w1:minjul_w13, min),
              proj = unique(proj),
              period_counter = unique(period_counter)) %>% 
    ungroup() 
  
  # reorganize outputs for modeling
  ystack <- ystack2_group %>% select(V1:V13)
  covs <- ystack2_group %>% select(-(V1:V13))
  
  # attach preannotate variables 
  static <- cell_ID 
  #static <- readRDS("data/data_for_annotation/Covs_WI_cell_20221126_static.rds")
  # annual <- readRDS("data/data_for_annotation/Covs_WI_cell_20221126_annual.rds") %>% 
  #   mutate(year = as.character(year))
  # seasonal <- readRDS("data/data_for_annotation/Covs_WI_cell_20221126_seasonal.rds")
  
  # merge environmental and anthropogenic information previously extracted
  covs <- left_join(covs, cell_ID, by="cellID", rlationship="many-to-many") #warning is fine 
  # covs <- left_join(covs, annual)
  # covs <- left_join(covs, seasonal)
  
  # Save files to run model on HPC
  filename <- paste("data_for_modelling/", species, "_", Sys.Date(), ".RData", sep = "")
  save(ystack, covs, species, file = filename)
  
}else{
  
  #' Save files to run model on HPC
  filename <- paste("data/data_for_modeling/", species, "_", Sys.Date(), ".RData", sep = "")
  save(ystack, covs, species, file = filename)
}
